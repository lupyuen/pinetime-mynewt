/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
#[cfg(feature = "NOTUSED")]  ////  TODO
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const SENSOR_VALUE_TYPE_OPAQUE: u32 = 0;
pub const SENSOR_VALUE_TYPE_INT32: u32 = 1;
pub const SENSOR_VALUE_TYPE_FLOAT: u32 = 2;
pub const SENSOR_VALUE_TYPE_INT32_TRIPLET: u32 = 3;
pub const SENSOR_VALUE_TYPE_FLOAT_TRIPLET: u32 = 4;
pub const SENSOR_ITF_SPI: u32 = 0;
pub const SENSOR_ITF_I2C: u32 = 1;
pub const SENSOR_ITF_UART: u32 = 2;
pub const SENSOR_THRESH_ALGO_WINDOW: u32 = 1;
pub const SENSOR_THRESH_ALGO_WATERMARK: u32 = 2;
pub const SENSOR_THRESH_ALGO_USERDEF: u32 = 3;
pub const SENSOR_IGN_LISTENER: u32 = 1;
pub type __uint8_t = ::cty::c_uchar;
pub type __int16_t = ::cty::c_short;
pub type __uint16_t = ::cty::c_ushort;
pub type __int32_t = ::cty::c_long;
pub type __uint32_t = ::cty::c_ulong;
pub type __int64_t = ::cty::c_longlong;
pub type os_stack_t = u32;
pub type os_time_t = u32;
pub type os_event_fn = ::core::option::Option<unsafe extern "C" fn(ev: *mut os_event)>;
#[repr(C)]
pub struct os_event__bindgen_ty_1 {
    pub stqe_next: *mut os_event,
}
impl Default for os_event__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_eventq__bindgen_ty_1 {
    pub stqh_first: *mut os_event,
    pub stqh_last: *mut *mut os_event,
}
impl Default for os_eventq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_callout__bindgen_ty_1 {
    pub tqe_next: *mut os_callout,
    pub tqe_prev: *mut *mut os_callout,
}
impl Default for os_callout__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Initialize a device."]
#[doc = ""]
#[doc = " - __`dev`__: The device to initialize."]
#[doc = " - __`arg`__: User defined argument to pass to the device initalization"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type os_dev_init_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut os_dev, arg2: *mut ::cty::c_void) -> ::cty::c_int,
>;
pub type os_dev_open_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut os_dev, arg2: u32, arg3: *mut ::cty::c_void) -> ::cty::c_int,
>;
pub type os_dev_suspend_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut os_dev, arg2: os_time_t, arg3: ::cty::c_int) -> ::cty::c_int,
>;
pub type os_dev_resume_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut os_dev) -> ::cty::c_int>;
pub type os_dev_close_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut os_dev) -> ::cty::c_int>;
#[repr(C)]
pub struct os_dev__bindgen_ty_1 {
    pub stqe_next: *mut os_dev,
}
impl Default for os_dev__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_memblock__bindgen_ty_1 {
    pub sle_next: *mut os_memblock,
}
impl Default for os_memblock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_mempool__bindgen_ty_1 {
    pub stqe_next: *mut os_mempool,
}
impl Default for os_mempool__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_mempool__bindgen_ty_2 {
    pub slh_first: *mut os_memblock,
}
impl Default for os_mempool__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type os_membuf_t = u32;
#[repr(C)]
pub struct os_mutex__bindgen_ty_1 {
    pub slh_first: *mut os_task,
}
impl Default for os_mutex__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type os_sanity_check_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut os_sanity_check, arg2: *mut ::cty::c_void) -> ::cty::c_int,
>;
#[repr(C)]
pub struct os_sanity_check__bindgen_ty_1 {
    pub sle_next: *mut os_sanity_check,
}
impl Default for os_sanity_check__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type os_task_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::cty::c_void)>;
#[repr(C)]
pub struct os_task__bindgen_ty_1 {
    pub stqe_next: *mut os_task,
}
impl Default for os_task__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_task__bindgen_ty_2 {
    pub tqe_next: *mut os_task,
    pub tqe_prev: *mut *mut os_task,
}
impl Default for os_task__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_task__bindgen_ty_3 {
    pub sle_next: *mut os_task,
}
impl Default for os_task__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Package init function. Remove when we have post-kernel init stages."]
    pub fn sensor_pkg_init();
}
pub const sensor_type_t_SENSOR_TYPE_NONE: sensor_type_t = 0;
pub const sensor_type_t_SENSOR_TYPE_ACCELEROMETER: sensor_type_t = 1;
pub const sensor_type_t_SENSOR_TYPE_MAGNETIC_FIELD: sensor_type_t = 2;
pub const sensor_type_t_SENSOR_TYPE_GYROSCOPE: sensor_type_t = 4;
pub const sensor_type_t_SENSOR_TYPE_LIGHT: sensor_type_t = 8;
pub const sensor_type_t_SENSOR_TYPE_TEMPERATURE: sensor_type_t = 16;
pub const sensor_type_t_SENSOR_TYPE_AMBIENT_TEMPERATURE: sensor_type_t = 32;
pub const sensor_type_t_SENSOR_TYPE_PRESSURE: sensor_type_t = 64;
pub const sensor_type_t_SENSOR_TYPE_PROXIMITY: sensor_type_t = 128;
pub const sensor_type_t_SENSOR_TYPE_RELATIVE_HUMIDITY: sensor_type_t = 256;
pub const sensor_type_t_SENSOR_TYPE_ROTATION_VECTOR: sensor_type_t = 512;
pub const sensor_type_t_SENSOR_TYPE_ALTITUDE: sensor_type_t = 1024;
pub const sensor_type_t_SENSOR_TYPE_WEIGHT: sensor_type_t = 2048;
pub const sensor_type_t_SENSOR_TYPE_LINEAR_ACCEL: sensor_type_t = 4096;
pub const sensor_type_t_SENSOR_TYPE_GRAVITY: sensor_type_t = 8192;
pub const sensor_type_t_SENSOR_TYPE_EULER: sensor_type_t = 16384;
pub const sensor_type_t_SENSOR_TYPE_COLOR: sensor_type_t = 32768;
pub const sensor_type_t_SENSOR_TYPE_USER_DEFINED_1: sensor_type_t = 67108864;
pub const sensor_type_t_SENSOR_TYPE_USER_DEFINED_2: sensor_type_t = 134217728;
pub const sensor_type_t_SENSOR_TYPE_USER_DEFINED_3: sensor_type_t = 268435456;
pub const sensor_type_t_SENSOR_TYPE_USER_DEFINED_4: sensor_type_t = 536870912;
pub const sensor_type_t_SENSOR_TYPE_USER_DEFINED_5: sensor_type_t = 1073741824;
pub const sensor_type_t_SENSOR_TYPE_USER_DEFINED_6: sensor_type_t = -2147483648;
pub const sensor_type_t_SENSOR_TYPE_ALL: sensor_type_t = 4294967295;
pub type sensor_type_t = i64;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_DOUBLE_TAP: sensor_event_type_t = 1;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_SINGLE_TAP: sensor_event_type_t = 2;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_FREE_FALL: sensor_event_type_t = 4;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_SLEEP_CHANGE: sensor_event_type_t = 8;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_WAKEUP: sensor_event_type_t = 16;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_SLEEP: sensor_event_type_t = 32;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_CHANGE: sensor_event_type_t = 64;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_X_CHANGE: sensor_event_type_t = 128;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_Y_CHANGE: sensor_event_type_t = 256;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_Z_CHANGE: sensor_event_type_t = 512;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_X_L_CHANGE: sensor_event_type_t = 1024;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_Y_L_CHANGE: sensor_event_type_t = 2048;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_Z_L_CHANGE: sensor_event_type_t = 4096;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_X_H_CHANGE: sensor_event_type_t = 8192;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_Y_H_CHANGE: sensor_event_type_t = 16384;
pub const sensor_event_type_t_SENSOR_EVENT_TYPE_ORIENT_Z_H_CHANGE: sensor_event_type_t = 32768;
pub type sensor_event_type_t = u32;
#[doc = " Configuration structure, describing a specific sensor type off of"]
#[doc = " an existing sensor."]
#[repr(C)]
#[derive(Default)]
pub struct sensor_cfg {
    pub sc_valtype: u8,
    pub _reserved: [u8; 3usize],
}
#[repr(C)]
pub struct sensor_data_t {
    pub smd: __BindgenUnionField<*mut sensor_mag_data>,
    pub sad: __BindgenUnionField<*mut sensor_accel_data>,
    pub sed: __BindgenUnionField<*mut sensor_euler_data>,
    pub sqd: __BindgenUnionField<*mut sensor_quat_data>,
    pub slad: __BindgenUnionField<*mut sensor_accel_data>,
    pub sgrd: __BindgenUnionField<*mut sensor_accel_data>,
    pub sgd: __BindgenUnionField<*mut sensor_gyro_data>,
    pub std: __BindgenUnionField<*mut sensor_temp_data>,
    pub satd: __BindgenUnionField<*mut sensor_temp_data>,
    pub sld: __BindgenUnionField<*mut sensor_light_data>,
    pub scd: __BindgenUnionField<*mut sensor_color_data>,
    pub spd: __BindgenUnionField<*mut sensor_press_data>,
    pub srhd: __BindgenUnionField<*mut sensor_humid_data>,
    pub bindgen_union_field: u64,
}
impl Default for sensor_data_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Callback for handling sensor data, specified in a sensor listener."]
#[doc = ""]
#[doc = " - __`sensor`__: The sensor for which data is being returned"]
#[doc = " - __`arg`__: The argument provided to sensor_read() function."]
#[doc = " - __`data`__: A single sensor reading for that sensor listener"]
#[doc = " - __`type`__: The sensor type for the data function"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_data_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut sensor,
        arg2: *mut ::cty::c_void,
        arg3: *mut ::cty::c_void,
        arg4: sensor_type_t,
    ) -> ::cty::c_int,
>;
#[doc = " Callback for sending trigger notification."]
#[doc = ""]
#[doc = " - __`sensor`__: Ptr to the sensor"]
#[doc = " - __`data`__: Ptr to sensor data"]
#[doc = " - __`type`__: The sensor type"]
pub type sensor_trigger_notify_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut sensor,
        arg2: *mut ::cty::c_void,
        arg3: sensor_type_t,
    ) -> ::cty::c_int,
>;
#[doc = " Callback for trigger compare functions."]
#[doc = ""]
#[doc = " - __`type`__: Type of sensor"]
#[doc = " - __`low_thresh`__: The sensor low threshold"]
#[doc = " - __`high_thresh`__: The sensor high threshold"]
#[doc = " - __`arg`__: Ptr to data"]
pub type sensor_trigger_cmp_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: sensor_type_t,
        arg2: *mut sensor_data_t,
        arg3: *mut sensor_data_t,
        arg4: *mut ::cty::c_void,
    ) -> ::cty::c_int,
>;
#[doc = " Callback for event notifications."]
#[doc = ""]
#[doc = " - __`sensor`__: The sensor that observed the event"]
#[doc = " - __`arg`__: The opaque argument provided during registration"]
#[doc = " - __`event`__: The sensor event type that was observed"]
pub type sensor_notifier_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut sensor,
        arg2: *mut ::cty::c_void,
        arg3: sensor_event_type_t,
    ) -> ::cty::c_int,
>;
#[doc = " Callback for reporting a sensor read error."]
#[doc = ""]
#[doc = " - __`sensor`__: The sensor for which a read failed."]
#[doc = " - __`arg`__: The optional argument registered with the callback."]
#[doc = " - __`status`__: Indicates the cause of the read failure.  Determined by the"]
#[doc = "               underlying sensor driver."]
pub type sensor_error_func_t = ::core::option::Option<
    unsafe extern "C" fn(sensor: *mut sensor, arg: *mut ::cty::c_void, status: ::cty::c_int),
>;
#[repr(C)]
pub struct sensor_listener {
    pub sl_sensor_type: sensor_type_t,
    pub sl_func: sensor_data_func_t,
    pub sl_arg: *mut ::cty::c_void,
    pub sl_next: sensor_listener__bindgen_ty_1,
}
#[repr(C)]
pub struct sensor_listener__bindgen_ty_1 {
    pub sle_next: *mut sensor_listener,
}
impl Default for sensor_listener__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sensor_listener {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Registration for sensor event notifications"]
#[repr(C)]
pub struct sensor_notifier {
    pub sn_sensor_event_type: sensor_event_type_t,
    pub sn_func: sensor_notifier_func_t,
    pub sn_arg: *mut ::cty::c_void,
    pub sn_next: sensor_notifier__bindgen_ty_1,
}
#[repr(C)]
pub struct sensor_notifier__bindgen_ty_1 {
    pub sle_next: *mut sensor_notifier,
}
impl Default for sensor_notifier__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sensor_notifier {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Context for sensor read events"]
#[repr(C)]
pub struct sensor_read_ev_ctx {
    pub srec_sensor: *mut sensor,
    pub srec_type: sensor_type_t,
}
impl Default for sensor_read_ev_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Sensor type traits list"]
#[repr(C)]
pub struct sensor_type_traits {
    pub stt_sensor_type: sensor_type_t,
    pub stt_low_thresh: sensor_data_t,
    pub stt_high_thresh: sensor_data_t,
    pub stt_algo: u8,
    pub stt_poll_n: u16,
    pub stt_polls_left: u16,
    pub stt_trigger_cmp_algo: sensor_trigger_cmp_func_t,
    pub stt_sensor: *mut sensor,
    pub stt_next: sensor_type_traits__bindgen_ty_1,
}
#[repr(C)]
pub struct sensor_type_traits__bindgen_ty_1 {
    pub sle_next: *mut sensor_type_traits,
}
impl Default for sensor_type_traits__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sensor_type_traits {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct sensor_notify_ev_ctx {
    pub snec_sensor: *mut sensor,
    pub snec_evtype: sensor_event_type_t,
}
impl Default for sensor_notify_ev_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct sensor_notify_os_ev {
    pub snoe_evt: os_event,
    pub snoe_evtype: sensor_event_type_t,
    pub snoe_sensor: *mut sensor,
}
impl Default for sensor_notify_os_ev {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Read a single value from a sensor, given a specific sensor type"]
#[doc = " (e.g. SENSOR_TYPE_PROXIMITY)."]
#[doc = ""]
#[doc = " - __`sensor`__: The sensor to read from"]
#[doc = " - __`type`__: The type(s) of sensor values to read.  Mask containing that type, provide"]
#[doc = "        all, to get all values."]
#[doc = " - __`data_func`__: The function to call with each value read.  If NULL, it calls all"]
#[doc = "        sensor listeners associated with this function."]
#[doc = " - __`arg`__: The argument to pass to the read callback."]
#[doc = " - __`timeout`__: Timeout. If block until result, specify OS_TIMEOUT_NEVER, 0 returns"]
#[doc = "        immediately (no wait.)"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_read_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut sensor,
        arg2: sensor_type_t,
        arg3: sensor_data_func_t,
        arg4: *mut ::cty::c_void,
        arg5: u32,
    ) -> ::cty::c_int,
>;
#[doc = " Get the configuration of the sensor for the sensor type.  This includes"]
#[doc = " the value type of the sensor."]
#[doc = ""]
#[doc = " - __`sensor`__: Ptr to the sensor"]
#[doc = " - __`type`__: The type of sensor value to get configuration for"]
#[doc = " - __`cfg`__: A pointer to the sensor value to place the returned result into."]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_get_config_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut sensor,
        arg2: sensor_type_t,
        arg3: *mut sensor_cfg,
    ) -> ::cty::c_int,
>;
#[doc = " Send a new configuration register set to the sensor."]
#[doc = ""]
#[doc = " - __`sensor`__: Ptr to the sensor-specific stucture"]
#[doc = " - __`arg`__: Ptr to the sensor-specific configuration structure"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_set_config_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sensor, arg2: *mut ::cty::c_void) -> ::cty::c_int,
>;
#[doc = " Set the trigger and threshold values for a specific sensor for the sensor"]
#[doc = " type."]
#[doc = ""]
#[doc = " - __`sensor`__: Ptr to the sensor"]
#[doc = " - __`type`__: type of sensor"]
#[doc = " - __`stt`__: Ptr to teh sensor traits"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_set_trigger_thresh_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut sensor,
        arg2: sensor_type_t,
        stt: *mut sensor_type_traits,
    ) -> ::cty::c_int,
>;
#[doc = " Clear the high/low threshold values for a specific sensor for the sensor"]
#[doc = " type."]
#[doc = ""]
#[doc = " - __`sensor`__: Ptr to the sensor"]
#[doc = " - __`type`__: Type of sensor"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_clear_trigger_thresh_t = ::core::option::Option<
    unsafe extern "C" fn(sensor: *mut sensor, type_: sensor_type_t) -> ::cty::c_int,
>;
#[doc = " Set the notification expectation for a targeted set of events for the"]
#[doc = " specific sensor. After this function returns successfully, the implementer"]
#[doc = " shall post corresponding event notifications to the sensor manager."]
#[doc = ""]
#[doc = " - __`sensor`__: The sensor to expect notifications from."]
#[doc = " - __`event`__: The mask of event types to expect notifications from."]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_set_notification_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sensor, arg2: sensor_event_type_t) -> ::cty::c_int,
>;
#[doc = " Unset the notification expectation for a targeted set of events for the"]
#[doc = " specific sensor."]
#[doc = ""]
#[doc = " - __`sensor`__: The sensor."]
#[doc = " - __`event`__: The mask of event types."]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_unset_notification_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sensor, arg2: sensor_event_type_t) -> ::cty::c_int,
>;
#[doc = " Let driver handle interrupt in the sensor context"]
#[doc = ""]
#[doc = " - __`sensor`__: Ptr to the sensor"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type sensor_handle_interrupt_t =
    ::core::option::Option<unsafe extern "C" fn(sensor: *mut sensor) -> ::cty::c_int>;
#[doc = " Reset Sensor function Ptr"]
#[doc = ""]
#[doc = " - __`Ptr`__: to the sensor"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero on failure"]
pub type sensor_reset_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut sensor) -> ::cty::c_int>;
#[repr(C)]
#[derive(Default)]
pub struct sensor_driver {
    pub sd_read: sensor_read_func_t,
    pub sd_get_config: sensor_get_config_func_t,
    pub sd_set_config: sensor_set_config_func_t,
    pub sd_set_trigger_thresh: sensor_set_trigger_thresh_t,
    pub sd_clear_low_trigger_thresh: sensor_clear_trigger_thresh_t,
    pub sd_clear_high_trigger_thresh: sensor_clear_trigger_thresh_t,
    pub sd_set_notification: sensor_set_notification_t,
    pub sd_unset_notification: sensor_unset_notification_t,
    pub sd_handle_interrupt: sensor_handle_interrupt_t,
    pub sd_reset: sensor_reset_t,
}
#[repr(C)]
pub struct sensor_timestamp {
    pub st_ostv: os_timeval,
    pub st_ostz: os_timezone,
    pub st_cputime: u32,
}
impl Default for sensor_timestamp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct sensor_int {
    pub host_pin: u8,
    pub device_pin: u8,
    pub active: u8,
}
#[repr(C)]
pub struct sensor_itf {
    pub si_type: u8,
    pub si_num: u8,
    pub si_cs_pin: u8,
    pub si_addr: u16,
    pub si_lock: *mut os_mutex,
    pub si_low_pin: u8,
    pub si_high_pin: u8,
    pub si_ints: [sensor_int; 2usize],
}
impl Default for sensor_itf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct sensor {
    pub s_dev: *mut os_dev,
    pub s_lock: os_mutex,
    pub s_types: sensor_type_t,
    pub s_mask: sensor_type_t,
    #[doc = " Poll rate in MS for this sensor."]
    pub s_poll_rate: u32,
    pub s_next_run: os_time_t,
    pub s_funcs: *mut sensor_driver,
    pub s_sts: sensor_timestamp,
    pub s_itf: sensor_itf,
    pub s_interrupt_evt: os_event,
    pub s_listener_list: sensor__bindgen_ty_1,
    pub s_err_fn: sensor_error_func_t,
    pub s_err_arg: *mut ::cty::c_void,
    pub s_notifier_list: sensor__bindgen_ty_2,
    pub s_type_traits_list: sensor__bindgen_ty_3,
    pub s_next: sensor__bindgen_ty_4,
}
#[repr(C)]
pub struct sensor__bindgen_ty_1 {
    pub slh_first: *mut sensor_listener,
}
impl Default for sensor__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct sensor__bindgen_ty_2 {
    pub slh_first: *mut sensor_notifier,
}
impl Default for sensor__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct sensor__bindgen_ty_3 {
    pub slh_first: *mut sensor_type_traits,
}
impl Default for sensor__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct sensor__bindgen_ty_4 {
    pub sle_next: *mut sensor,
}
impl Default for sensor__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sensor {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Read context for calling user function with argument"]
#[repr(C)]
pub struct sensor_read_ctx {
    pub user_func: sensor_data_func_t,
    pub user_arg: *mut ::cty::c_void,
}
impl Default for sensor_read_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Lock access to the sensor_itf specified by si.  Blocks until lock acquired."]
    #[doc = ""]
    #[doc = " - __`si`__: The sensor_itf to lock"]
    #[doc = " - __`timeout`__: The timeout"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn sensor_itf_lock(si: *mut sensor_itf, timeout: os_time_t) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Unlock access to the sensor_itf specified by si."]
    #[doc = ""]
    #[doc = " - __`si`__: The sensor_itf to unlock access to"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn sensor_itf_unlock(si: *mut sensor_itf);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a sensor"]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor to initialize"]
    #[doc = " - __`dev`__: The device to associate with this sensor."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn sensor_init(sensor: *mut sensor, dev: *mut os_dev) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Lock access to the sensor specified by sensor.  Blocks until lock acquired."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor to lock"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn sensor_lock(sensor: *mut sensor) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Unlock access to the sensor specified by sensor."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor to unlock access to."]
    pub fn sensor_unlock(sensor: *mut sensor);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Register a sensor listener. This allows a calling application to receive"]
    #[doc = " callbacks for data from a given sensor object."]
    #[doc = ""]
    #[doc = " For more information on the type of callbacks available, see the documentation"]
    #[doc = " for the sensor listener structure."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor to register a listener on"]
    #[doc = " - __`listener`__: The listener to register onto the sensor"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn sensor_register_listener(
        sensor: *mut sensor,
        listener: *mut sensor_listener,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Un-register a sensor listener. This allows a calling application to clear"]
    #[doc = " callbacks for a given sensor object."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor object"]
    #[doc = " - __`listener`__: The listener to remove from the sensor listener list"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn sensor_unregister_listener(
        sensor: *mut sensor,
        listener: *mut sensor_listener,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Register a sensor error callback.  The callback is executed when the sensor"]
    #[doc = " manager fails to read from the given sensor."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor to register an error callback on."]
    #[doc = " - __`err_fn`__: The function to execute when a read fails."]
    #[doc = " - __`arg`__: Optional argument to pass to the callback."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn sensor_register_err_func(
        sensor: *mut sensor,
        err_fn: sensor_error_func_t,
        arg: *mut ::cty::c_void,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Register a sensor notifier. This allows a calling application to receive"]
    #[doc = " callbacks any time a requested event is observed."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor to register the notifier on"]
    #[doc = " - __`notifier`__: The notifier to register"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn sensor_register_notifier(
        sensor: *mut sensor,
        notifier: *mut sensor_notifier,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Un-register a sensor notifier. This allows a calling application to stop"]
    #[doc = " receiving callbacks for events on the sensor object."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor object to un-register the notifier on"]
    #[doc = " - __`notifier`__: The notifier to remove from the notification list"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn sensor_unregister_notifier(
        sensor: *mut sensor,
        notifier: *mut sensor_notifier,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Read the data for sensor type \"type,\" from the given sensor and"]
    #[doc = " return the result into the \"value\" parameter."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor to read data from"]
    #[doc = " - __`type`__: The type of sensor data to read from the sensor"]
    #[doc = " - __`data_func`__: The callback to call for data returned from that sensor"]
    #[doc = " - __`arg`__: The argument to pass to this callback."]
    #[doc = " - __`timeout`__: Timeout before aborting sensor read"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn sensor_read(
        sensor: *mut sensor,
        type_: sensor_type_t,
        data_func: sensor_data_func_t,
        arg: *mut ::cty::c_void,
        timeout: u32,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Lock sensor manager to access the list of sensors"]
    pub fn sensor_mgr_lock() -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Unlock sensor manager once the list of sensors has been accessed"]
    pub fn sensor_mgr_unlock();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Register the sensor with the global sensor list. This makes the sensor"]
    #[doc = " searchable by other packages, who may want to look it up by type."]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor to register"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn sensor_mgr_register(sensor: *mut sensor) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the current eventq, the system is misconfigured if there is still"]
    #[doc = " no parent eventq."]
    #[doc = ""]
    #[doc = " Return: Ptr OS eventq that the sensor mgr is set to"]
    pub fn sensor_mgr_evq_get() -> *mut os_eventq;
}
pub type sensor_mgr_compare_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sensor, arg2: *mut ::cty::c_void) -> ::cty::c_int,
>;
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " The sensor manager contains a list of sensors, this function returns"]
    #[doc = " the next sensor in that list, for which compare_func() returns successful"]
    #[doc = " (one).  If prev_cursor is provided, the function starts at that point"]
    #[doc = " in the sensor list."]
    #[doc = ""]
    #[doc = " @warn This function MUST be locked by sensor_mgr_lock/unlock() if the goal is"]
    #[doc = " to iterate through sensors (as opposed to just finding one.)  As the"]
    #[doc = " \"prev_cursor\" may be resorted in the sensor list, in between calls."]
    #[doc = ""]
    #[doc = " - __`compare_func`__: The comparison function to use against sensors in the list."]
    #[doc = " - __`arg`__: The argument to provide to that comparison function"]
    #[doc = " - __`prev_cursor`__: The previous sensor in the sensor manager list, in case of"]
    #[doc = "        iteration.  If desire is to find first matching sensor, provide a"]
    #[doc = "        NULL value."]
    #[doc = ""]
    #[doc = " Return: A pointer to the first sensor found from prev_cursor, or"]
    #[doc = "         NULL, if none found."]
    #[doc = ""]
    pub fn sensor_mgr_find_next(
        arg1: sensor_mgr_compare_func_t,
        arg2: *mut ::cty::c_void,
        arg3: *mut sensor,
    ) -> *mut sensor;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Find the \"next\" sensor available for a given sensor type."]
    #[doc = ""]
    #[doc = " If the sensor parameter, is present find the next entry from that"]
    #[doc = " parameter.  Otherwise, find the first matching sensor."]
    #[doc = ""]
    #[doc = " - __`type`__: The type of sensor to search for"]
    #[doc = " - __`sensor`__: The cursor to search from, or NULL to start from the beginning."]
    #[doc = ""]
    #[doc = " Return: A pointer to the sensor object matching that sensor type, or NULL if"]
    #[doc = "         none found."]
    pub fn sensor_mgr_find_next_bytype(type_: sensor_type_t, sensor: *mut sensor) -> *mut sensor;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Search the sensor list and find the next sensor that corresponds"]
    #[doc = " to a given device name."]
    #[doc = ""]
    #[doc = " - __`devname`__: The device name to search for"]
    #[doc = " - __`sensor`__: The previous sensor found with this device name"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure"]
    pub fn sensor_mgr_find_next_bydevname(
        devname: *const ::cty::c_char,
        prev_cursor: *mut sensor,
    ) -> *mut sensor;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check if sensor type matches"]
    #[doc = ""]
    #[doc = " - __`sensor`__: The sensor object"]
    #[doc = " - __`arg`__: type to check"]
    #[doc = ""]
    #[doc = " Return: 1 if matches, 0 if it doesn't match."]
    pub fn sensor_mgr_match_bytype(sensor: *mut sensor, arg1: *mut ::cty::c_void) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the sensor poll rate"]
    #[doc = ""]
    #[doc = " - __`devname`__: Name of the sensor"]
    #[doc = " - __`poll_rate`__: The poll rate in milli seconds"]
    pub fn sensor_set_poll_rate_ms(devname: *const ::cty::c_char, poll_rate: u32) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the sensor poll rate multiple based on the device name, sensor type"]
    #[doc = ""]
    #[doc = " - __`devname`__: Name of the sensor"]
    #[doc = " - __`stt`__: The sensor type trait"]
    pub fn sensor_set_n_poll_rate(
        devname: *const ::cty::c_char,
        stt: *mut sensor_type_traits,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Transmit OIC trigger"]
    #[doc = ""]
    #[doc = " - __`sensor`__: Ptr to the sensor"]
    #[doc = " - __`arg`__: Ptr to sensor data"]
    #[doc = " - __`type`__: The sensor type"]
    #[doc = ""]
    #[doc = " Return: 0 on sucess, non-zero on failure"]
    pub fn sensor_oic_tx_trigger(
        sensor: *mut sensor,
        arg: *mut ::cty::c_void,
        type_: sensor_type_t,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Sensor trigger initialization"]
    #[doc = ""]
    #[doc = " - __`sensor`__: Ptr to the sensor"]
    #[doc = " - __`type`__: Sensor type to enable trigger for"]
    #[doc = " - __`notify`__: the function to call if the trigger condition is satisfied"]
    pub fn sensor_trigger_init(
        sensor: *mut sensor,
        type_: sensor_type_t,
        notify: sensor_trigger_notify_func_t,
    );
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Search the sensor type traits list for specific type of sensor"]
    #[doc = ""]
    #[doc = " - __`type`__: The sensor type to search for"]
    #[doc = " - __`sensor`__: Ptr to a sensor"]
    #[doc = ""]
    #[doc = " Return: NULL when no sensor type is found, ptr to sensor_type_traits structure"]
    #[doc = " when found"]
    pub fn sensor_get_type_traits_bytype(
        type_: sensor_type_t,
        sensor: *mut sensor,
    ) -> *mut sensor_type_traits;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the type traits for a sensor"]
    #[doc = ""]
    #[doc = " - __`devname`__: Name of the sensor"]
    #[doc = " - __`stt`__: Ptr to sensor types trait struct"]
    #[doc = " - __`type`__: The sensor type"]
    #[doc = ""]
    #[doc = " Return: NULL on failure, sensor struct on success"]
    pub fn sensor_get_type_traits_byname(
        arg1: *const ::cty::c_char,
        arg2: *mut *mut sensor_type_traits,
        arg3: sensor_type_t,
    ) -> *mut sensor;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the thresholds along with the comparison algo for a sensor"]
    #[doc = ""]
    #[doc = " - __`devname`__: Name of the sensor"]
    #[doc = " - __`stt`__: Ptr to sensor type traits containing thresholds"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure"]
    pub fn sensor_set_thresh(
        devname: *const ::cty::c_char,
        stt: *mut sensor_type_traits,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Clears the low threshold for a sensor"]
    #[doc = ""]
    #[doc = " - __`devname`__: Name of the sensor"]
    #[doc = " - __`type`__: The sensor type"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure"]
    pub fn sensor_clear_low_thresh(
        devname: *const ::cty::c_char,
        type_: sensor_type_t,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Clears the high threshold for a sensor"]
    #[doc = ""]
    #[doc = " - __`devname`__: Name of the sensor"]
    #[doc = " - __`type`__: The sensor type"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure"]
    pub fn sensor_clear_high_thresh(
        devname: *const ::cty::c_char,
        type_: sensor_type_t,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Puts a notification event on the sensor manager evq"]
    #[doc = ""]
    #[doc = " - __`ctx`__: Notification event context"]
    #[doc = " - __`evtype`__: The notification event type"]
    pub fn sensor_mgr_put_notify_evt(ctx: *mut sensor_notify_ev_ctx, evtype: sensor_event_type_t);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Puts a interrupt event on the sensor manager evq"]
    #[doc = ""]
    #[doc = " - __`sensor`__: Sensor Ptr as interrupt event context"]
    pub fn sensor_mgr_put_interrupt_evt(sensor: *mut sensor);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Puts read event on the sensor manager evq"]
    #[doc = ""]
    #[doc = " - __`arg`__: Argument"]
    pub fn sensor_mgr_put_read_evt(arg: *mut ::cty::c_void);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Resets the sensor"]
    #[doc = ""]
    #[doc = " - __`Ptr`__: to sensor"]
    pub fn sensor_reset(sensor: *mut sensor) -> ::cty::c_int;
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_accel_data {
    pub sad_x: f32,
    pub sad_y: f32,
    pub sad_z: f32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_accel_data {
    #[inline]
    pub fn sad_x_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sad_x_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sad_y_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sad_y_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sad_z_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sad_z_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sad_x_is_valid: u8,
        sad_y_is_valid: u8,
        sad_z_is_valid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sad_x_is_valid: u8 = unsafe { ::core::mem::transmute(sad_x_is_valid) };
            sad_x_is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sad_y_is_valid: u8 = unsafe { ::core::mem::transmute(sad_y_is_valid) };
            sad_y_is_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sad_z_is_valid: u8 = unsafe { ::core::mem::transmute(sad_z_is_valid) };
            sad_z_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_mag_data {
    pub smd_x: f32,
    pub smd_y: f32,
    pub smd_z: f32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_mag_data {
    #[inline]
    pub fn smd_x_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_smd_x_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smd_y_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_smd_y_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smd_z_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_smd_z_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        smd_x_is_valid: u8,
        smd_y_is_valid: u8,
        smd_z_is_valid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let smd_x_is_valid: u8 = unsafe { ::core::mem::transmute(smd_x_is_valid) };
            smd_x_is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let smd_y_is_valid: u8 = unsafe { ::core::mem::transmute(smd_y_is_valid) };
            smd_y_is_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let smd_z_is_valid: u8 = unsafe { ::core::mem::transmute(smd_z_is_valid) };
            smd_z_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_light_data {
    pub sld_full: u16,
    pub sld_ir: u16,
    pub sld_lux: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_light_data {
    #[inline]
    pub fn sld_full_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sld_full_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sld_ir_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sld_ir_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sld_lux_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sld_lux_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sld_full_is_valid: u8,
        sld_ir_is_valid: u8,
        sld_lux_is_valid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sld_full_is_valid: u8 = unsafe { ::core::mem::transmute(sld_full_is_valid) };
            sld_full_is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sld_ir_is_valid: u8 = unsafe { ::core::mem::transmute(sld_ir_is_valid) };
            sld_ir_is_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sld_lux_is_valid: u8 = unsafe { ::core::mem::transmute(sld_lux_is_valid) };
            sld_lux_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_quat_data {
    pub sqd_x: f32,
    pub sqd_y: f32,
    pub sqd_z: f32,
    pub sqd_w: f32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_quat_data {
    #[inline]
    pub fn sqd_x_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sqd_x_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sqd_y_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sqd_y_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sqd_z_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sqd_z_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sqd_w_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sqd_w_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sqd_x_is_valid: u8,
        sqd_y_is_valid: u8,
        sqd_z_is_valid: u8,
        sqd_w_is_valid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sqd_x_is_valid: u8 = unsafe { ::core::mem::transmute(sqd_x_is_valid) };
            sqd_x_is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sqd_y_is_valid: u8 = unsafe { ::core::mem::transmute(sqd_y_is_valid) };
            sqd_y_is_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sqd_z_is_valid: u8 = unsafe { ::core::mem::transmute(sqd_z_is_valid) };
            sqd_z_is_valid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sqd_w_is_valid: u8 = unsafe { ::core::mem::transmute(sqd_w_is_valid) };
            sqd_w_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_euler_data {
    pub sed_h: f32,
    pub sed_r: f32,
    pub sed_p: f32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_euler_data {
    #[inline]
    pub fn sed_h_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sed_h_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sed_r_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sed_r_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sed_p_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sed_p_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sed_h_is_valid: u8,
        sed_r_is_valid: u8,
        sed_p_is_valid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sed_h_is_valid: u8 = unsafe { ::core::mem::transmute(sed_h_is_valid) };
            sed_h_is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sed_r_is_valid: u8 = unsafe { ::core::mem::transmute(sed_r_is_valid) };
            sed_r_is_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sed_p_is_valid: u8 = unsafe { ::core::mem::transmute(sed_p_is_valid) };
            sed_p_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_color_data {
    pub scd_r: u16,
    pub scd_g: u16,
    pub scd_b: u16,
    pub scd_c: u16,
    pub scd_lux: u16,
    pub scd_colortemp: u16,
    pub scd_saturation: u16,
    pub scd_saturation75: u16,
    pub scd_is_sat: u8,
    pub scd_cratio: f32,
    pub scd_maxlux: u16,
    pub scd_ir: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl sensor_color_data {
    #[inline]
    pub fn scd_r_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_r_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_g_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_g_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_b_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_b_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_c_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_c_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_lux_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_lux_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_colortemp_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_colortemp_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_saturation_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_saturation_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_saturation75_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_saturation75_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_is_sat_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_is_sat_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_cratio_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_cratio_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_maxlux_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_maxlux_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scd_ir_is_valid(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scd_ir_is_valid(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scd_r_is_valid: u16,
        scd_g_is_valid: u16,
        scd_b_is_valid: u16,
        scd_c_is_valid: u16,
        scd_lux_is_valid: u16,
        scd_colortemp_is_valid: u16,
        scd_saturation_is_valid: u16,
        scd_saturation75_is_valid: u16,
        scd_is_sat_is_valid: u16,
        scd_cratio_is_valid: u16,
        scd_maxlux_is_valid: u16,
        scd_ir_is_valid: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scd_r_is_valid: u16 = unsafe { ::core::mem::transmute(scd_r_is_valid) };
            scd_r_is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scd_g_is_valid: u16 = unsafe { ::core::mem::transmute(scd_g_is_valid) };
            scd_g_is_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let scd_b_is_valid: u16 = unsafe { ::core::mem::transmute(scd_b_is_valid) };
            scd_b_is_valid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scd_c_is_valid: u16 = unsafe { ::core::mem::transmute(scd_c_is_valid) };
            scd_c_is_valid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scd_lux_is_valid: u16 = unsafe { ::core::mem::transmute(scd_lux_is_valid) };
            scd_lux_is_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scd_colortemp_is_valid: u16 =
                unsafe { ::core::mem::transmute(scd_colortemp_is_valid) };
            scd_colortemp_is_valid as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scd_saturation_is_valid: u16 =
                unsafe { ::core::mem::transmute(scd_saturation_is_valid) };
            scd_saturation_is_valid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scd_saturation75_is_valid: u16 =
                unsafe { ::core::mem::transmute(scd_saturation75_is_valid) };
            scd_saturation75_is_valid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scd_is_sat_is_valid: u16 = unsafe { ::core::mem::transmute(scd_is_sat_is_valid) };
            scd_is_sat_is_valid as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scd_cratio_is_valid: u16 = unsafe { ::core::mem::transmute(scd_cratio_is_valid) };
            scd_cratio_is_valid as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scd_maxlux_is_valid: u16 = unsafe { ::core::mem::transmute(scd_maxlux_is_valid) };
            scd_maxlux_is_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scd_ir_is_valid: u16 = unsafe { ::core::mem::transmute(scd_ir_is_valid) };
            scd_ir_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_temp_data {
    pub std_temp: f32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_temp_data {
    #[inline]
    pub fn std_temp_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_std_temp_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(std_temp_is_valid: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let std_temp_is_valid: u8 = unsafe { ::core::mem::transmute(std_temp_is_valid) };
            std_temp_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_press_data {
    pub spd_press: f32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_press_data {
    #[inline]
    pub fn spd_press_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_spd_press_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(spd_press_is_valid: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let spd_press_is_valid: u8 = unsafe { ::core::mem::transmute(spd_press_is_valid) };
            spd_press_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_humid_data {
    pub shd_humid: f32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_humid_data {
    #[inline]
    pub fn shd_humid_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shd_humid_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(shd_humid_is_valid: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shd_humid_is_valid: u8 = unsafe { ::core::mem::transmute(shd_humid_is_valid) };
            shd_humid_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Default)]
pub struct sensor_gyro_data {
    pub sgd_x: f32,
    pub sgd_y: f32,
    pub sgd_z: f32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl sensor_gyro_data {
    #[inline]
    pub fn sgd_x_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sgd_x_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgd_y_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sgd_y_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgd_z_is_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sgd_z_is_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sgd_x_is_valid: u8,
        sgd_y_is_valid: u8,
        sgd_z_is_valid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sgd_x_is_valid: u8 = unsafe { ::core::mem::transmute(sgd_x_is_valid) };
            sgd_x_is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sgd_y_is_valid: u8 = unsafe { ::core::mem::transmute(sgd_y_is_valid) };
            sgd_y_is_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sgd_z_is_valid: u8 = unsafe { ::core::mem::transmute(sgd_z_is_valid) };
            sgd_z_is_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct _bindgen_ty_1 {
    pub mgr_lock: os_mutex,
    pub mgr_wakeup_callout: os_callout,
    pub mgr_eventq: *mut os_eventq,
    pub mgr_sensor_list: _bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
pub struct _bindgen_ty_1__bindgen_ty_1 {
    pub slh_first: *mut sensor,
}
impl Default for _bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub static mut sensor_mgr: _bindgen_ty_1;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub static mut sensor_base_ts: sensor_timestamp;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub static mut sensor_read_event: os_event;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub static mut sensor_notify_evt_pool: os_mempool;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub static mut sensor_notify_evt_area: [os_membuf_t; 60usize];
}
