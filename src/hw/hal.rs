/* automatically generated by rust-bindgen */

// use
// super::*;

pub const HAL_ADC_MODULE_ENABLED: u32 = 1;
pub const HAL_I2C_ERR_UNKNOWN: u32 = 1;
pub const HAL_I2C_ERR_INVAL: u32 = 2;
pub const HAL_I2C_ERR_TIMEOUT: u32 = 3;
pub const HAL_I2C_ERR_ADDR_NACK: u32 = 4;
pub const HAL_I2C_ERR_DATA_NACK: u32 = 5;
pub const HAL_SPI_TYPE_MASTER: u32 = 0;
pub const HAL_SPI_TYPE_SLAVE: u32 = 1;
pub const HAL_SPI_MODE0: u32 = 0;
pub const HAL_SPI_MODE1: u32 = 1;
pub const HAL_SPI_MODE2: u32 = 2;
pub const HAL_SPI_MODE3: u32 = 3;
pub const HAL_SPI_MSB_FIRST: u32 = 0;
pub const HAL_SPI_LSB_FIRST: u32 = 1;
pub const HAL_SPI_WORD_SIZE_8BIT: u32 = 0;
pub const HAL_SPI_WORD_SIZE_9BIT: u32 = 1;
#[doc = " Not connected"]
pub const hal_gpio_mode_e_HAL_GPIO_MODE_NC: hal_gpio_mode_e = -1;
#[doc = " Input"]
pub const hal_gpio_mode_e_HAL_GPIO_MODE_IN: hal_gpio_mode_e = 0;
#[doc = " Output"]
pub const hal_gpio_mode_e_HAL_GPIO_MODE_OUT: hal_gpio_mode_e = 1;
#[doc = " The \"mode\" of the gpio. The gpio is either an input, output, or it is"]
#[doc = " \"not connected\" (the pin specified is not functioning as a gpio)"]
pub type hal_gpio_mode_e = i32;
pub use self::hal_gpio_mode_e as hal_gpio_mode_t;
#[doc = " Pull-up/down not enabled"]
pub const hal_gpio_pull_HAL_GPIO_PULL_NONE: hal_gpio_pull = 0;
#[doc = " Pull-up enabled"]
pub const hal_gpio_pull_HAL_GPIO_PULL_UP: hal_gpio_pull = 1;
#[doc = " Pull-down enabled"]
pub const hal_gpio_pull_HAL_GPIO_PULL_DOWN: hal_gpio_pull = 2;
pub type hal_gpio_pull = u32;
pub use self::hal_gpio_pull as hal_gpio_pull_t;
pub const hal_gpio_irq_trigger_HAL_GPIO_TRIG_NONE: hal_gpio_irq_trigger = 0;
#[doc = " IRQ occurs on rising edge"]
pub const hal_gpio_irq_trigger_HAL_GPIO_TRIG_RISING: hal_gpio_irq_trigger = 1;
#[doc = " IRQ occurs on falling edge"]
pub const hal_gpio_irq_trigger_HAL_GPIO_TRIG_FALLING: hal_gpio_irq_trigger = 2;
#[doc = " IRQ occurs on either edge"]
pub const hal_gpio_irq_trigger_HAL_GPIO_TRIG_BOTH: hal_gpio_irq_trigger = 3;
#[doc = " IRQ occurs when line is low"]
pub const hal_gpio_irq_trigger_HAL_GPIO_TRIG_LOW: hal_gpio_irq_trigger = 4;
#[doc = " IRQ occurs when line is high"]
pub const hal_gpio_irq_trigger_HAL_GPIO_TRIG_HIGH: hal_gpio_irq_trigger = 5;
pub type hal_gpio_irq_trigger = u32;
pub use self::hal_gpio_irq_trigger as hal_gpio_irq_trig_t;
pub type hal_gpio_irq_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::cty::c_void)>;
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initializes the specified pin as an input"]
    #[doc = ""]
    #[doc = " - __`pin`__:   Pin number to set as input"]
    #[doc = " - __`pull`__:  pull type"]
    #[doc = ""]
    #[doc = " Return: int  0: no error; -1 otherwise."]
    pub fn hal_gpio_init_in(pin: ::cty::c_int, pull: hal_gpio_pull_t) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize the specified pin as an output, setting the pin to the specified"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " - __`pin`__: Pin number to set as output"]
    #[doc = " - __`val`__: Value to set pin"]
    #[doc = ""]
    #[doc = " Return: int  0: no error; -1 otherwise."]
    pub fn hal_gpio_init_out(pin: ::cty::c_int, val: ::cty::c_int) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Deinitialize the specified pin to revert the previous initialization"]
    #[doc = ""]
    #[doc = " - __`pin`__: Pin number to unset"]
    #[doc = ""]
    #[doc = " Return: int  0: no error; -1 otherwise."]
    pub fn hal_gpio_deinit(pin: ::cty::c_int) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Write a value (either high or low) to the specified pin."]
    #[doc = ""]
    #[doc = " - __`pin`__: Pin to set"]
    #[doc = " - __`val`__: Value to set pin (0:low 1:high)"]
    pub fn hal_gpio_write(pin: ::cty::c_int, val: ::cty::c_int);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reads the specified pin."]
    #[doc = ""]
    #[doc = " - __`pin`__: Pin number to read"]
    #[doc = ""]
    #[doc = " Return: int 0: low, 1: high"]
    pub fn hal_gpio_read(pin: ::cty::c_int) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Toggles the specified pin"]
    #[doc = ""]
    #[doc = " - __`pin`__: Pin number to toggle"]
    #[doc = ""]
    #[doc = " Return: current gpio state int 0: low, 1: high"]
    pub fn hal_gpio_toggle(pin: ::cty::c_int) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a given pin to trigger a GPIO IRQ callback."]
    #[doc = ""]
    #[doc = " - __`pin`__:     The pin to trigger GPIO interrupt on"]
    #[doc = " - __`handler`__: The handler function to call"]
    #[doc = " - __`arg`__:     The argument to provide to the IRQ handler"]
    #[doc = " - __`trig`__:    The trigger mode (e.g. rising, falling)"]
    #[doc = " - __`pull`__:    The mode of the pin (e.g. pullup, pulldown)"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn hal_gpio_irq_init(
        pin: ::cty::c_int,
        handler: hal_gpio_irq_handler_t,
        arg: *mut ::cty::c_void,
        trig: hal_gpio_irq_trig_t,
        pull: hal_gpio_pull_t,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Release a pin from being configured to trigger IRQ on state change."]
    #[doc = ""]
    #[doc = " - __`pin`__: The pin to release"]
    pub fn hal_gpio_irq_release(pin: ::cty::c_int);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable IRQs on the passed pin"]
    #[doc = ""]
    #[doc = " - __`pin`__: The pin to enable IRQs on"]
    pub fn hal_gpio_irq_enable(pin: ::cty::c_int);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Disable IRQs on the passed pin"]
    #[doc = ""]
    #[doc = " - __`pin`__: The pin to disable IRQs on"]
    pub fn hal_gpio_irq_disable(pin: ::cty::c_int);
}
pub type __uint8_t = ::cty::c_uchar;
pub type __uint16_t = ::cty::c_ushort;
pub type __uint32_t = ::cty::c_ulong;
#[doc = " I2C controller hardware settings"]
#[repr(C)]
#[derive(Default)]
pub struct hal_i2c_hw_settings {
    pub pin_scl: ::cty::c_int,
    pub pin_sda: ::cty::c_int,
}
#[doc = " I2C configuration"]
#[repr(C)]
#[derive(Default)]
pub struct hal_i2c_settings {
    #[doc = " Frequency in kHz"]
    pub frequency: u32,
}
#[doc = " When sending a packet, use this structure to pass the arguments."]
#[repr(C)]
pub struct hal_i2c_master_data {
    #[doc = " Destination address"]
    #[doc = " An I2C address has 7 bits. In the protocol these"]
    #[doc = " 7 bits are combined with a 1 bit R/W bit to specify read"]
    #[doc = " or write operation in an 8-bit address field sent to"]
    #[doc = " the remote device.  This API accepts the 7-bit"]
    #[doc = " address as its argument in the 7 LSBs of the"]
    #[doc = " address field above.  For example if I2C was"]
    #[doc = " writing a 0x81 in its protocol, you would pass"]
    #[doc = " only the top 7-bits to this function as 0x40"]
    pub address: u8,
    #[doc = " Number of buffer bytes to transmit or receive"]
    pub len: u16,
    #[doc = " Buffer space to hold the transmit or receive"]
    pub buffer: *mut u8,
}
impl Default for hal_i2c_master_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a new i2c device with the I2C number."]
    #[doc = ""]
    #[doc = " - __`i2c_num`__: The number of the I2C device being initialized"]
    #[doc = " - __`cfg`__: The hardware specific configuration structure to configure"]
    #[doc = "            the I2C with.  This includes things like pin configuration."]
    #[doc = ""]
    #[doc = " Return: 0 on success, and non-zero error code on failure"]
    pub fn hal_i2c_init(i2c_num: u8, cfg: *mut ::cty::c_void) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize I2C controller"]
    #[doc = ""]
    #[doc = " This initializes I2C controller hardware before 1st use. Shall be called"]
    #[doc = " only once."]
    #[doc = ""]
    #[doc = " - __`i2c_num`__:  Number of I2C controller"]
    #[doc = " - __`cfg`__:      Configuration"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure"]
    pub fn hal_i2c_init_hw(i2c_num: u8, cfg: *const hal_i2c_hw_settings) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable I2C controller"]
    #[doc = ""]
    #[doc = " This enables I2C controller before usage."]
    #[doc = ""]
    #[doc = " - __`i2c_num`__:  Number of I2C controller"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure"]
    pub fn hal_i2c_enable(i2c_num: u8) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Disable I2C controller"]
    #[doc = ""]
    #[doc = " This disabled I2C controller if no longer needed. Hardware configuration"]
    #[doc = " be preserved after controller is disabled."]
    #[doc = ""]
    #[doc = " - __`i2c_num`__:  Number of I2C controller"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure"]
    pub fn hal_i2c_disable(i2c_num: u8) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Configure I2C controller"]
    #[doc = ""]
    #[doc = " This configures I2C controller for operation. Can be called multiple times."]
    #[doc = ""]
    #[doc = " - __`i2c_num`__:  Number of I2C controller"]
    #[doc = " - __`cfg`__:      Configuration"]
    pub fn hal_i2c_config(i2c_num: u8, cfg: *const hal_i2c_settings) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Sends a start condition and writes <len> bytes of data on the i2c bus."]
    #[doc = " This API does NOT issue a stop condition unless `last_op` is set to `1`."]
    #[doc = " You must stop the bus after successful or unsuccessful write attempts."]
    #[doc = " This API is blocking until an error or NaK occurs. Timeout is platform"]
    #[doc = " dependent."]
    #[doc = ""]
    #[doc = " - __`i2c_num`__: The number of the I2C device being written to"]
    #[doc = " - __`pdata`__: The data to write to the I2C bus"]
    #[doc = " - __`timeout`__: How long to wait for transaction to complete in ticks"]
    #[doc = " - __`last_op`__: Master should send a STOP at the end to signify end of"]
    #[doc = "        transaction."]
    #[doc = ""]
    #[doc = " Return: 0 on success, and non-zero error code on failure"]
    pub fn hal_i2c_master_write(
        i2c_num: u8,
        pdata: *mut hal_i2c_master_data,
        timeout: u32,
        last_op: u8,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Sends a start condition and reads <len> bytes of data on the i2c bus."]
    #[doc = " This API does NOT issue a stop condition unless `last_op` is set to `1`."]
    #[doc = " You must stop the bus after successful or unsuccessful write attempts."]
    #[doc = " This API is blocking until an error or NaK occurs. Timeout is platform"]
    #[doc = " dependent."]
    #[doc = ""]
    #[doc = " - __`i2c_num`__: The number of the I2C device being written to"]
    #[doc = " - __`pdata`__: The location to place read data"]
    #[doc = " - __`timeout`__: How long to wait for transaction to complete in ticks"]
    #[doc = " - __`last_op`__: Master should send a STOP at the end to signify end of"]
    #[doc = "        transaction."]
    #[doc = ""]
    #[doc = " Return: 0 on success, and non-zero error code on failure"]
    pub fn hal_i2c_master_read(
        i2c_num: u8,
        pdata: *mut hal_i2c_master_data,
        timeout: u32,
        last_op: u8,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Probes the i2c bus for a device with this address.  THIS API"]
    #[doc = " issues a start condition, probes the address using a read"]
    #[doc = " command and issues a stop condition."]
    #[doc = ""]
    #[doc = " - __`i2c_num`__: The number of the I2C to probe"]
    #[doc = " - __`address`__: The address to probe for"]
    #[doc = " - __`timeout`__: How long to wait for transaction to complete in ticks"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure"]
    pub fn hal_i2c_master_probe(i2c_num: u8, address: u8, timeout: u32) -> ::cty::c_int;
}
pub type hal_spi_txrx_cb =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::cty::c_void, len: ::cty::c_int)>;
#[doc = " SPI controller hardware settings"]
#[repr(C)]
#[derive(Default)]
pub struct hal_spi_hw_settings {
    pub pin_sck: ::cty::c_int,
    pub pin_mosi: ::cty::c_int,
    pub pin_miso: ::cty::c_int,
    pub pin_ss: ::cty::c_int,
}
#[doc = " since one spi device can control multiple devices, some configuration"]
#[doc = " can be changed on the fly from the hal"]
#[repr(C)]
#[derive(Default)]
pub struct hal_spi_settings {
    #[doc = " Data mode of SPI driver, defined by HAL_SPI_MODEn"]
    pub data_mode: u8,
    #[doc = " Data order, either HAL_SPI_MSB_FIRST or HAL_SPI_LSB_FIRST"]
    pub data_order: u8,
    #[doc = " The word size of the SPI transaction, either 8-bit or 9-bit"]
    pub word_size: u8,
    #[doc = " Baudrate in kHz"]
    pub baudrate: u32,
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize the SPI, given by spi_num."]
    #[doc = ""]
    #[doc = " - __`spi_num`__: The number of the SPI to initialize"]
    #[doc = " - __`cfg`__: HW/MCU specific configuration,"]
    #[doc = "            passed to the underlying implementation, providing extra"]
    #[doc = "            configuration."]
    #[doc = " - __`spi_type`__: SPI type (master or slave)"]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    pub fn hal_spi_init(
        spi_num: ::cty::c_int,
        cfg: *mut ::cty::c_void,
        spi_type: u8,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize SPI controller"]
    #[doc = ""]
    #[doc = " This initializes SPI controller hardware before 1st use. Shall be called"]
    #[doc = " only once."]
    #[doc = ""]
    #[doc = " - __`spi_num`__:  Number of SPI controller"]
    #[doc = " - __`cfg`__:      Configuration"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure"]
    pub fn hal_spi_init_hw(
        spi_num: u8,
        spi_type: u8,
        cfg: *const hal_spi_hw_settings,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Configure the spi. Must be called after the spi is initialized (after"]
    #[doc = " hal_spi_init is called) and when the spi is disabled (user must call"]
    #[doc = " hal_spi_disable if the spi has been enabled through hal_spi_enable prior"]
    #[doc = " to calling this function). Can also be used to reconfigure an initialized"]
    #[doc = " SPI (assuming it is disabled as described previously)."]
    #[doc = ""]
    #[doc = " - __`spi_num`__: The number of the SPI to configure."]
    #[doc = " - __`psettings`__: The settings to configure this SPI with"]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    pub fn hal_spi_config(spi_num: ::cty::c_int, psettings: *mut hal_spi_settings) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Sets the txrx callback (executed at interrupt context) when the"]
    #[doc = " buffer is transferred by the master or the slave using the non-blocking API."]
    #[doc = " Cannot be called when the spi is enabled. This callback will also be called"]
    #[doc = " when chip select is de-asserted on the slave."]
    #[doc = ""]
    #[doc = " NOTE: This callback is only used for the non-blocking interface and must"]
    #[doc = " be called prior to using the non-blocking API."]
    #[doc = ""]
    #[doc = " - __`spi_num`__:   SPI interface on which to set callback"]
    #[doc = " - __`txrx`__:      Callback function"]
    #[doc = " - __`arg`__:       Argument to be passed to callback function"]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    pub fn hal_spi_set_txrx_cb(
        spi_num: ::cty::c_int,
        txrx_cb: hal_spi_txrx_cb,
        arg: *mut ::cty::c_void,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enables the SPI. This does not start a transmit or receive operation;"]
    #[doc = " it is used for power mgmt. Cannot be called when a SPI transfer is in"]
    #[doc = " progress."]
    #[doc = ""]
    #[doc = " @param spi_num"]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    pub fn hal_spi_enable(spi_num: ::cty::c_int) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Disables the SPI. Used for power mgmt. It will halt any current SPI transfers"]
    #[doc = " in progress."]
    #[doc = ""]
    #[doc = " @param spi_num"]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    pub fn hal_spi_disable(spi_num: ::cty::c_int) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Blocking call to send a value on the SPI. Returns the value received from the"]
    #[doc = " SPI slave."]
    #[doc = ""]
    #[doc = " MASTER: Sends the value and returns the received value from the slave."]
    #[doc = " SLAVE: Invalid API. Returns 0xFFFF"]
    #[doc = ""]
    #[doc = " - __`spi_num`__:   Spi interface to use"]
    #[doc = " - __`val`__:       Value to send"]
    #[doc = ""]
    #[doc = " Return: uint16_t Value received on SPI interface from slave. Returns 0xFFFF"]
    #[doc = " if called when the SPI is configured to be a slave"]
    pub fn hal_spi_tx_val(spi_num: ::cty::c_int, val: u16) -> u16;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Blocking interface to send a buffer and store the received values from the"]
    #[doc = " slave. The transmit and receive buffers are either arrays of 8-bit (uint8_t)"]
    #[doc = " values or 16-bit values depending on whether the spi is configured for 8 bit"]
    #[doc = " data or more than 8 bits per value. The 'cnt' parameter is the number of"]
    #[doc = " 8-bit or 16-bit values. Thus, if 'cnt' is 10, txbuf/rxbuf would point to an"]
    #[doc = " array of size 10 (in bytes) if the SPI is using 8-bit data; otherwise"]
    #[doc = " txbuf/rxbuf would point to an array of size 20 bytes (ten, uint16_t values)."]
    #[doc = ""]
    #[doc = " NOTE: these buffers are in the native endian-ness of the platform."]
    #[doc = ""]
    #[doc = "     MASTER: master sends all the values in the buffer and stores the"]
    #[doc = "             stores the values in the receive buffer if rxbuf is not NULL."]
    #[doc = "             The txbuf parameter cannot be NULL."]
    #[doc = "     SLAVE: cannot be called for a slave; returns -1"]
    #[doc = ""]
    #[doc = " - __`spi_num`__:   SPI interface to use"]
    #[doc = " - __`txbuf`__:     Pointer to buffer where values to transmit are stored."]
    #[doc = " - __`rxbuf`__:     Pointer to buffer to store values received from peer."]
    #[doc = " - __`cnt`__:       Number of 8-bit or 16-bit values to be transferred."]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    pub fn hal_spi_txrx(
        spi_num: ::cty::c_int,
        txbuf: *mut ::cty::c_void,
        rxbuf: *mut ::cty::c_void,
        cnt: ::cty::c_int,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Non-blocking interface to send a buffer and store received values. Can be"]
    #[doc = " used for both master and slave SPI types. The user must configure the"]
    #[doc = " callback (using hal_spi_set_txrx_cb); the txrx callback is executed at"]
    #[doc = " interrupt context when the buffer is sent."]
    #[doc = ""]
    #[doc = " The transmit and receive buffers are either arrays of 8-bit (uint8_t)"]
    #[doc = " values or 16-bit values depending on whether the spi is configured for 8 bit"]
    #[doc = " data or more than 8 bits per value. The 'cnt' parameter is the number of"]
    #[doc = " 8-bit or 16-bit values. Thus, if 'cnt' is 10, txbuf/rxbuf would point to an"]
    #[doc = " array of size 10 (in bytes) if the SPI is using 8-bit data; otherwise"]
    #[doc = " txbuf/rxbuf would point to an array of size 20 bytes (ten, uint16_t values)."]
    #[doc = ""]
    #[doc = " NOTE: these buffers are in the native endian-ness of the platform."]
    #[doc = ""]
    #[doc = "     MASTER: master sends all the values in the buffer and stores the"]
    #[doc = "             stores the values in the receive buffer if rxbuf is not NULL."]
    #[doc = "             The txbuf parameter cannot be NULL"]
    #[doc = "     SLAVE: Slave \"preloads\" the data to be sent to the master (values"]
    #[doc = "            stored in txbuf) and places received data from master in rxbuf"]
    #[doc = "            (if not NULL). The txrx callback occurs when len values are"]
    #[doc = "            transferred or master de-asserts chip select. If txbuf is NULL,"]
    #[doc = "            the slave transfers its default byte. Both rxbuf and txbuf cannot"]
    #[doc = "            be NULL."]
    #[doc = ""]
    #[doc = " - __`spi_num`__:   SPI interface to use"]
    #[doc = " - __`txbuf`__:     Pointer to buffer where values to transmit are stored."]
    #[doc = " - __`rxbuf`__:     Pointer to buffer to store values received from peer."]
    #[doc = " - __`cnt`__:       Number of 8-bit or 16-bit values to be transferred."]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    pub fn hal_spi_txrx_noblock(
        spi_num: ::cty::c_int,
        txbuf: *mut ::cty::c_void,
        rxbuf: *mut ::cty::c_void,
        cnt: ::cty::c_int,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Sets the default value transferred by the slave. Not valid for master"]
    #[doc = ""]
    #[doc = " - __`spi_num`__: SPI interface to use"]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    pub fn hal_spi_slave_set_def_tx_val(spi_num: ::cty::c_int, val: u16) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " This aborts the current transfer but keeps the spi enabled."]
    #[doc = ""]
    #[doc = " - __`spi_num`__:   SPI interface on which transfer should be aborted."]
    #[doc = ""]
    #[doc = " Return: int 0 on success, non-zero error code on failure."]
    #[doc = ""]
    #[doc = " NOTE: does not return an error if no transfer was in progress."]
    pub fn hal_spi_abort(spi_num: ::cty::c_int) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Extracts CPOL and CPHA values from a data-mode constant."]
    #[doc = " Utility function, defined once for every MCU."]
    #[doc = ""]
    #[doc = " - __`data_mode`__:             The HAL_SPI_MODE value to convert."]
    #[doc = " - __`out_cpol`__:              The CPOL gets written here on success."]
    #[doc = " - __`out_cpha`__:              The CPHA gets written here on success."]
    #[doc = ""]
    #[doc = " Return:                      0 on success; nonzero on invalid input."]
    pub fn hal_spi_data_mode_breakout(
        data_mode: u8,
        out_cpol: *mut ::cty::c_int,
        out_cpha: *mut ::cty::c_int,
    ) -> ::cty::c_int;
}
