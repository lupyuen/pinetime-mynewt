/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
#[cfg(feature = "NOTUSED")]  ////  TODO
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const OS_WAIT_FOREVER: i32 = -1;
pub const OS_IDLE_PRIO: u32 = 255;
pub const OS_TICKS_PER_SEC: u32 = 1000;
pub const OS_SANITY_STACK_SIZE: u32 = 64;
pub const OS_IDLE_STACK_SIZE: u32 = 64;
pub const OS_STACK_PATTERN: u32 = 3735928559;
pub const OS_ALIGNMENT: u32 = 4;
pub const OS_STACK_ALIGNMENT: u32 = 8;
pub const OS_TIME_MAX: u32 = 4294967295;
pub const OS_STIME_MAX: u32 = 2147483647;
pub const OS_TIMEOUT_NEVER: u32 = 4294967295;
pub const OS_DEV_INIT_PRIMARY: u32 = 1;
pub const OS_DEV_INIT_SECONDARY: u32 = 2;
pub const OS_DEV_INIT_KERNEL: u32 = 3;
pub const OS_DEV_INIT_F_CRITICAL: u32 = 1;
pub const OS_DEV_INIT_PRIO_DEFAULT: u32 = 255;
pub const OS_DEV_F_STATUS_READY: u32 = 1;
pub const OS_DEV_F_STATUS_OPEN: u32 = 2;
pub const OS_DEV_F_STATUS_SUSPENDED: u32 = 4;
pub const OS_DEV_F_INIT_CRITICAL: u32 = 8;
pub const OS_MEMPOOL_F_EXT: u32 = 1;
pub const OS_MEMPOOL_INFO_NAME_LEN: u32 = 32;
pub const OS_TASK_PRI_HIGHEST: u32 = 0;
pub const OS_TASK_PRI_LOWEST: u32 = 255;
pub const OS_TASK_FLAG_NO_TIMEOUT: u32 = 1;
pub const OS_TASK_FLAG_SEM_WAIT: u32 = 2;
pub const OS_TASK_FLAG_MUTEX_WAIT: u32 = 4;
pub const OS_TASK_FLAG_EVQ_WAIT: u32 = 8;
pub const OS_TASK_MAX_NAME_LEN: u32 = 32;
pub const OS_TRACE_ID_EVENTQ_PUT: u32 = 40;
pub const OS_TRACE_ID_EVENTQ_GET_NO_WAIT: u32 = 41;
pub const OS_TRACE_ID_EVENTQ_GET: u32 = 42;
pub const OS_TRACE_ID_EVENTQ_REMOVE: u32 = 43;
pub const OS_TRACE_ID_EVENTQ_POLL_0TIMO: u32 = 44;
pub const OS_TRACE_ID_EVENTQ_POLL: u32 = 45;
pub const OS_TRACE_ID_MUTEX_INIT: u32 = 50;
pub const OS_TRACE_ID_MUTEX_RELEASE: u32 = 51;
pub const OS_TRACE_ID_MUTEX_PEND: u32 = 52;
pub const OS_TRACE_ID_SEM_INIT: u32 = 60;
pub const OS_TRACE_ID_SEM_RELEASE: u32 = 61;
pub const OS_TRACE_ID_SEM_PEND: u32 = 62;
pub const OS_TRACE_ID_CALLOUT_INIT: u32 = 70;
pub const OS_TRACE_ID_CALLOUT_STOP: u32 = 71;
pub const OS_TRACE_ID_CALLOUT_RESET: u32 = 72;
pub const OS_TRACE_ID_CALLOUT_TICK: u32 = 73;
pub const OS_TRACE_ID_MEMBLOCK_GET: u32 = 80;
pub const OS_TRACE_ID_MEMBLOCK_PUT_FROM_CB: u32 = 81;
pub const OS_TRACE_ID_MEMBLOCK_PUT: u32 = 82;
pub const OS_TRACE_ID_MBUF_GET: u32 = 90;
pub const OS_TRACE_ID_MBUF_GET_PKTHDR: u32 = 91;
pub const OS_TRACE_ID_MBUF_FREE: u32 = 92;
pub const OS_TRACE_ID_MBUF_FREE_CHAIN: u32 = 93;
pub const SYS_EOK: u32 = 0;
pub const SYS_ENOMEM: i32 = -1;
pub const SYS_EINVAL: i32 = -2;
pub const SYS_ETIMEOUT: i32 = -3;
pub const SYS_ENOENT: i32 = -4;
pub const SYS_EIO: i32 = -5;
pub const SYS_EAGAIN: i32 = -6;
pub const SYS_EACCES: i32 = -7;
pub const SYS_EBUSY: i32 = -8;
pub const SYS_ENODEV: i32 = -9;
pub const SYS_ERANGE: i32 = -10;
pub const SYS_EALREADY: i32 = -11;
pub const SYS_ENOTSUP: i32 = -12;
pub const SYS_EUNKNOWN: i32 = -13;
pub const SYS_EREMOTEIO: i32 = -14;
pub const SYS_EDONE: i32 = -15;
pub const SYS_EPERUSER: i32 = -65535;
pub const OS_RUN_PRIV: u32 = 0;
pub const OS_RUN_UNPRIV: u32 = 1;
pub type __uint8_t = ::cty::c_uchar;
pub type __int16_t = ::cty::c_short;
pub type __uint16_t = ::cty::c_ushort;
pub type __int32_t = ::cty::c_long;
pub type __uint32_t = ::cty::c_ulong;
pub type __int64_t = ::cty::c_longlong;
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_info_init() -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_init_idle_task();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check whether or not the OS has been started."]
    #[doc = ""]
    #[doc = " Return: 1 if the OS has been started and 0 if it has not yet been started."]
    pub fn os_started() -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize the OS, including memory areas and housekeeping functions."]
    #[doc = " This calls into the architecture specific OS initialization."]
    #[doc = ""]
    #[doc = " - __`fn`__: The system \"main\" function to start the main task with."]
    pub fn os_init(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(argc: ::cty::c_int, argv: *mut *mut ::cty::c_char) -> ::cty::c_int,
        >,
    );
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Start the OS and begin processing."]
    pub fn os_start();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reboots the system."]
    pub fn os_reboot(reason: ::cty::c_int);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Performs a system reset.  This is typically done at the end of a reboot"]
    #[doc = " procedure."]
    pub fn os_system_reset();
}
pub type os_sr_t = u32;
pub type os_stack_t = u32;
pub const os_error_OS_OK: os_error = 0;
pub const os_error_OS_ENOMEM: os_error = 1;
pub const os_error_OS_EINVAL: os_error = 2;
pub const os_error_OS_INVALID_PARM: os_error = 3;
pub const os_error_OS_MEM_NOT_ALIGNED: os_error = 4;
pub const os_error_OS_BAD_MUTEX: os_error = 5;
pub const os_error_OS_TIMEOUT: os_error = 6;
pub const os_error_OS_ERR_IN_ISR: os_error = 7;
pub const os_error_OS_ERR_PRIV: os_error = 8;
pub const os_error_OS_NOT_STARTED: os_error = 9;
pub const os_error_OS_ENOENT: os_error = 10;
pub const os_error_OS_EBUSY: os_error = 11;
pub const os_error_OS_ERROR: os_error = 12;
pub type os_error = u32;
pub use self::os_error as os_error_t;
#[repr(C)]
pub struct os_stack {
    _unused: [u8; 0],
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_task_stack_init(
        arg1: *mut os_task,
        arg2: *mut os_stack_t,
        arg3: ::cty::c_int,
    ) -> *mut os_stack_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_ctx_sw(arg1: *mut os_task);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_save_sr() -> os_sr_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_restore_sr(arg1: os_sr_t);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_in_critical() -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_init();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_start() -> u32;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_os_init() -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_os_start() -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_set_env(arg1: *mut os_stack_t);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_arch_init_task_stack(sf: *mut os_stack_t);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_default_irq_asm();
}
pub type os_time_t = u32;
pub type os_stime_t = i32;
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the current OS time in ticks"]
    #[doc = ""]
    #[doc = " Return: OS time in ticks"]
    pub fn os_time_get() -> os_time_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Move OS time forward ticks."]
    #[doc = ""]
    #[doc = " - __`ticks`__: The number of ticks to move time forward."]
    pub fn os_time_advance(ticks: ::cty::c_int);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Puts the current task to sleep for the specified number of os ticks. There"]
    #[doc = " is no delay if ticks is 0."]
    #[doc = ""]
    #[doc = " - __`osticks`__: Number of ticks to delay (0 means no delay)."]
    pub fn os_time_delay(osticks: os_time_t);
}
#[doc = " Structure representing time since Jan 1 1970 with microsecond"]
#[doc = " granularity"]
#[repr(C)]
#[derive(Default)]
pub struct os_timeval {
    pub tv_sec: i64,
    pub tv_usec: i32,
}
#[doc = " Structure representing a timezone offset"]
#[repr(C)]
#[derive(Default)]
pub struct os_timezone {
    #[doc = " Minutes west of GMT"]
    pub tz_minuteswest: i16,
    #[doc = " Daylight savings time correction (if any)"]
    pub tz_dsttime: i16,
}
#[doc = " Represents a time change.  Passed to time change listeners when the current"]
#[doc = " time-of-day is set."]
#[repr(C)]
pub struct os_time_change_info {
    #[doc = " UTC time prior to change."]
    pub tci_prev_tv: *const os_timeval,
    #[doc = " Time zone prior to change."]
    pub tci_prev_tz: *const os_timezone,
    #[doc = " UTC time after change."]
    pub tci_cur_tv: *const os_timeval,
    #[doc = " Time zone after change."]
    pub tci_cur_tz: *const os_timezone,
    pub tci_newly_synced: bool,
}
impl Default for os_time_change_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Callback that is executed when the time-of-day is set."]
#[doc = ""]
#[doc = " - __`info`__:                  Describes the time change that just occurred."]
#[doc = " - __`arg`__:                   Optional argument correponding to listener."]
pub type os_time_change_fn = ::core::option::Option<
    unsafe extern "C" fn(info: *const os_time_change_info, arg: *mut ::cty::c_void),
>;
#[doc = " Time change listener.  Notified when the time-of-day is set."]
#[repr(C)]
pub struct os_time_change_listener {
    #[doc = " Public."]
    pub tcl_fn: os_time_change_fn,
    pub tcl_arg: *mut ::cty::c_void,
    pub tcl_next: os_time_change_listener__bindgen_ty_1,
}
#[doc = " Internal."]
#[repr(C)]
pub struct os_time_change_listener__bindgen_ty_1 {
    pub stqe_next: *mut os_time_change_listener,
}
impl Default for os_time_change_listener__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_time_change_listener {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the time of day.  This does not modify os time, but rather just modifies"]
    #[doc = " the offset by which we are tracking real time against os time.  This"]
    #[doc = " function notifies all registered time change listeners."]
    #[doc = ""]
    #[doc = " - __`utctime`__: A timeval representing the UTC time we are setting"]
    #[doc = " - __`tz`__: The time-zone to apply against the utctime being set."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn os_settimeofday(utctime: *mut os_timeval, tz: *mut os_timezone) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the current time of day.  Returns the time of day in UTC"]
    #[doc = " into the tv argument, and returns the timezone (if set) into"]
    #[doc = " tz."]
    #[doc = ""]
    #[doc = " - __`tv`__: The structure to put the UTC time of day into"]
    #[doc = " - __`tz`__: The structure to put the timezone information into"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure"]
    pub fn os_gettimeofday(utctime: *mut os_timeval, tz: *mut os_timezone) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_time_is_set() -> bool;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get time since boot in microseconds."]
    #[doc = ""]
    #[doc = " Return: time since boot in microseconds"]
    pub fn os_get_uptime_usec() -> i64;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get time since boot as os_timeval."]
    #[doc = ""]
    #[doc = " - __`tv`__: Structure to put the time since boot."]
    pub fn os_get_uptime(tvp: *mut os_timeval);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Converts milliseconds to OS ticks."]
    #[doc = ""]
    #[doc = " - __`ms`__:                    The milliseconds input."]
    #[doc = " - __`out_ticks`__:             The OS ticks output."]
    #[doc = ""]
    #[doc = " Return:                      0 on success; OS_EINVAL if the result is too"]
    #[doc = "                                  large to fit in a uint32_t."]
    pub fn os_time_ms_to_ticks(ms: u32, out_ticks: *mut os_time_t) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Converts OS ticks to milliseconds."]
    #[doc = ""]
    #[doc = " - __`ticks`__:                 The OS ticks input."]
    #[doc = " - __`out_ms`__:                The milliseconds output."]
    #[doc = ""]
    #[doc = " Return:                      0 on success; OS_EINVAL if the result is too"]
    #[doc = "                                  large to fit in a uint32_t."]
    pub fn os_time_ticks_to_ms(ticks: os_time_t, out_ms: *mut u32) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Registers a time change listener.  Whenever the time is set, all registered"]
    #[doc = " listeners are notified.  The provided pointer is added to an internal list,"]
    #[doc = " so the listener's lifetime must extend indefinitely (or until the listener"]
    #[doc = " is removed)."]
    #[doc = ""]
    #[doc = " NOTE: This function is not thread safe.  The following operations must be"]
    #[doc = " kept exclusive:"]
    #[doc = "     o Addition of listener"]
    #[doc = "     o Removal of listener"]
    #[doc = "     o Setting time"]
    #[doc = ""]
    #[doc = " - __`listener`__:              The listener to register."]
    pub fn os_time_change_listen(listener: *mut os_time_change_listener);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Unregisters a time change listener."]
    #[doc = ""]
    #[doc = " NOTE: This function is not thread safe.  The following operations must be"]
    #[doc = " kept exclusive:"]
    #[doc = "     o Addition of listener"]
    #[doc = "     o Removal of listener"]
    #[doc = "     o Setting time"]
    #[doc = ""]
    #[doc = " - __`listener`__:              The listener to unregister."]
    pub fn os_time_change_remove(listener: *const os_time_change_listener) -> ::cty::c_int;
}
pub type os_event_fn = ::core::option::Option<unsafe extern "C" fn(ev: *mut os_event)>;
#[doc = " Structure representing an OS event.  OS events get placed onto the"]
#[doc = " event queues and are consumed by tasks."]
#[repr(C)]
pub struct os_event {
    #[doc = " Whether this OS event is queued on an event queue."]
    pub ev_queued: u8,
    #[doc = " Callback to call when the event is taken off of an event queue."]
    #[doc = " APIs, except for os_eventq_run(), assume this callback will be called by"]
    #[doc = " the user."]
    pub ev_cb: os_event_fn,
    #[doc = " Argument to pass to the event queue callback."]
    pub ev_arg: *mut ::cty::c_void,
    pub ev_next: os_event__bindgen_ty_1,
}
#[repr(C)]
pub struct os_event__bindgen_ty_1 {
    pub stqe_next: *mut os_event,
}
impl Default for os_event__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_event {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_eventq {
    #[doc = " Pointer to task that \"owns\" this event queue."]
    pub evq_owner: *mut os_task,
    #[doc = " Pointer to the task that is sleeping on this event queue, either NULL,"]
    #[doc = " or the owner task."]
    pub evq_task: *mut os_task,
    pub evq_list: os_eventq__bindgen_ty_1,
}
#[repr(C)]
pub struct os_eventq__bindgen_ty_1 {
    pub stqh_first: *mut os_event,
    pub stqh_last: *mut *mut os_event,
}
impl Default for os_eventq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_eventq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize the event queue"]
    #[doc = ""]
    #[doc = " - __`evq`__: The event queue to initialize"]
    pub fn os_eventq_init(arg1: *mut os_eventq);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check whether the event queue is initialized."]
    #[doc = ""]
    #[doc = " - __`evq`__: The event queue to check"]
    pub fn os_eventq_inited(evq: *const os_eventq) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Put an event on the event queue."]
    #[doc = ""]
    #[doc = " - __`evq`__: The event queue to put an event on"]
    #[doc = " - __`ev`__: The event to put on the queue"]
    pub fn os_eventq_put(arg1: *mut os_eventq, arg2: *mut os_event);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Poll an event from the event queue and return it immediately."]
    #[doc = " If no event is available, don't block, just return NULL."]
    #[doc = ""]
    #[doc = " Return: Event from the queue, or NULL if none available."]
    pub fn os_eventq_get_no_wait(evq: *mut os_eventq) -> *mut os_event;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Pull a single item from an event queue.  This function blocks until there"]
    #[doc = " is an item on the event queue to read."]
    #[doc = ""]
    #[doc = " - __`evq`__: The event queue to pull an event from"]
    #[doc = ""]
    #[doc = " Return: The event from the queue"]
    pub fn os_eventq_get(arg1: *mut os_eventq) -> *mut os_event;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Pull a single item off the event queue and call it's event"]
    #[doc = " callback."]
    #[doc = ""]
    #[doc = " - __`evq`__: The event queue to pull the item off."]
    pub fn os_eventq_run(evq: *mut os_eventq);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Poll the list of event queues specified by the evq parameter"]
    #[doc = " (size nevqs), and return the \"first\" event available on any of"]
    #[doc = " the queues.  Event queues are searched in the order that they"]
    #[doc = " are passed in the array."]
    #[doc = ""]
    #[doc = " - __`evq`__: Array of event queues"]
    #[doc = " - __`nevqs`__: Number of event queues in evq"]
    #[doc = " - __`timo`__: Timeout, forever if OS_WAIT_FOREVER is passed to poll."]
    #[doc = ""]
    #[doc = " Return: An event, or NULL if no events available"]
    pub fn os_eventq_poll(
        arg1: *mut *mut os_eventq,
        arg2: ::cty::c_int,
        arg3: os_time_t,
    ) -> *mut os_event;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Remove an event from the queue."]
    #[doc = ""]
    #[doc = " - __`evq`__: The event queue to remove the event from"]
    #[doc = " - __`ev`__:  The event to remove from the queue"]
    pub fn os_eventq_remove(arg1: *mut os_eventq, arg2: *mut os_event);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Retrieves the default event queue processed by OS main task."]
    #[doc = ""]
    #[doc = " Return:                      The default event queue."]
    pub fn os_eventq_dflt_get() -> *mut os_eventq;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @cond INTERNAL_HIDDEN"]
    #[doc = " [DEPRECATED]"]
    pub fn os_eventq_designate(
        dst: *mut *mut os_eventq,
        val: *mut os_eventq,
        start_ev: *mut os_event,
    );
}
#[doc = " Structure containing the definition of a callout, initialized"]
#[doc = " by os_callout_init() and passed to callout functions."]
#[repr(C)]
pub struct os_callout {
    #[doc = " Event to post when the callout expires."]
    pub c_ev: os_event,
    #[doc = " Pointer to the event queue to post the event to"]
    pub c_evq: *mut os_eventq,
    #[doc = " Number of ticks in the future to expire the callout"]
    pub c_ticks: os_time_t,
    pub c_next: os_callout__bindgen_ty_1,
}
#[repr(C)]
pub struct os_callout__bindgen_ty_1 {
    pub tqe_next: *mut os_callout,
    pub tqe_prev: *mut *mut os_callout,
}
impl Default for os_callout__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_callout {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
pub struct os_callout_list {
    pub tqh_first: *mut os_callout,
    pub tqh_last: *mut *mut os_callout,
}
impl Default for os_callout_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a callout."]
    #[doc = ""]
    #[doc = " Callouts are used to schedule events in the future onto a task's event"]
    #[doc = " queue.  Callout timers are scheduled using the os_callout_reset()"]
    #[doc = " function.  When the timer expires, an event is posted to the event"]
    #[doc = " queue specified in os_callout_init().  The event argument given here"]
    #[doc = " is posted in the ev_arg field of that event."]
    #[doc = ""]
    #[doc = " - __`c`__: The callout to initialize"]
    #[doc = " - __`evq`__: The event queue to post an OS_EVENT_T_TIMER event to"]
    #[doc = " - __`timo_func`__: The function to call on this callout for the host task"]
    #[doc = "                  used to provide multiple timer events to a task"]
    #[doc = "                  (this can be NULL.)"]
    #[doc = " - __`ev_arg`__: The argument to provide to the event when posting the"]
    #[doc = "               timer."]
    pub fn os_callout_init(
        cf: *mut os_callout,
        evq: *mut os_eventq,
        ev_cb: os_event_fn,
        ev_arg: *mut ::cty::c_void,
    );
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Stop the callout from firing off, any pending events will be cleared."]
    #[doc = ""]
    #[doc = " - __`c`__: The callout to stop"]
    pub fn os_callout_stop(arg1: *mut os_callout);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reset the callout to fire off in 'ticks' ticks."]
    #[doc = ""]
    #[doc = " - __`c`__: The callout to reset"]
    #[doc = " - __`ticks`__: The number of ticks to wait before posting an event"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure"]
    pub fn os_callout_reset(arg1: *mut os_callout, arg2: os_time_t) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Returns the number of ticks which remains to callout."]
    #[doc = ""]
    #[doc = " - __`c`__: The callout to check"]
    #[doc = " - __`now`__: The current time in OS ticks"]
    #[doc = ""]
    #[doc = " Return: Number of ticks to first pending callout"]
    pub fn os_callout_remaining_ticks(arg1: *mut os_callout, arg2: os_time_t) -> os_time_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @cond INTERNAL_HIDDEN"]
    pub fn os_callout_tick();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_callout_wakeup_ticks(now: os_time_t) -> os_time_t;
}
pub type hal_timer_cb = ::core::option::Option<unsafe extern "C" fn(arg: *mut ::cty::c_void)>;
#[doc = " The HAL timer structure. The user can declare as many of these structures"]
#[doc = " as desired. They are enqueued on a particular HW timer queue when the user"]
#[doc = " calls the :c:func:`hal_timer_start()` or :c:func:`hal_timer_start_at()` API."]
#[doc = " The user must have called :c:func:`hal_timer_set_cb()` before starting a"]
#[doc = " timer."]
#[doc = ""]
#[doc = " NOTE: the user should not have to modify/examine the contents of this"]
#[doc = " structure; the hal timer API should be used."]
#[repr(C)]
pub struct hal_timer {
    #[doc = " Internal platform specific pointer"]
    pub bsp_timer: *mut ::cty::c_void,
    #[doc = " Callback function"]
    pub cb_func: hal_timer_cb,
    #[doc = " Callback argument"]
    pub cb_arg: *mut ::cty::c_void,
    #[doc = " Tick at which timer should expire"]
    pub expiry: u32,
    pub link: hal_timer__bindgen_ty_1,
}
#[repr(C)]
pub struct hal_timer__bindgen_ty_1 {
    pub tqe_next: *mut hal_timer,
    pub tqe_prev: *mut *mut hal_timer,
}
impl Default for hal_timer__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for hal_timer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize the cputime module. This must be called after os_init is called"]
    #[doc = " and before any other timer API are used. This should be called only once"]
    #[doc = " and should be called before the hardware timer is used."]
    #[doc = ""]
    #[doc = " - __`clock_freq`__: The desired cputime frequency, in hertz (Hz)."]
    #[doc = ""]
    #[doc = " Return: int 0 on success; -1 on error."]
    pub fn os_cputime_init(clock_freq: u32) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Returns the low 32 bits of cputime."]
    #[doc = ""]
    #[doc = " Return: uint32_t The lower 32 bits of cputime"]
    pub fn os_cputime_get32() -> u32;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Converts the given number of nanoseconds into cputime ticks."]
    #[doc = " Not defined if OS_CPUTIME_FREQ_PWR2 is defined."]
    #[doc = ""]
    #[doc = " - __`usecs`__: The number of nanoseconds to convert to ticks"]
    #[doc = ""]
    #[doc = " Return: uint32_t The number of ticks corresponding to 'nsecs'"]
    pub fn os_cputime_nsecs_to_ticks(nsecs: u32) -> u32;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Convert the given number of ticks into nanoseconds."]
    #[doc = " Not defined if OS_CPUTIME_FREQ_PWR2 is defined."]
    #[doc = ""]
    #[doc = " - __`ticks`__: The number of ticks to convert to nanoseconds."]
    #[doc = ""]
    #[doc = " Return: uint32_t The number of nanoseconds corresponding to 'ticks'"]
    pub fn os_cputime_ticks_to_nsecs(ticks: u32) -> u32;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Wait until 'nsecs' nanoseconds has elapsed. This is a blocking delay."]
    #[doc = " Not defined if OS_CPUTIME_FREQ_PWR2 is defined."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " - __`nsecs`__: The number of nanoseconds to wait."]
    pub fn os_cputime_delay_nsecs(nsecs: u32);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Wait until the number of ticks has elapsed. This is a blocking delay."]
    #[doc = ""]
    #[doc = " - __`ticks`__: The number of ticks to wait."]
    pub fn os_cputime_delay_ticks(ticks: u32);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Wait until 'usecs' microseconds has elapsed. This is a blocking delay."]
    #[doc = ""]
    #[doc = " - __`usecs`__: The number of usecs to wait."]
    pub fn os_cputime_delay_usecs(usecs: u32);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a CPU timer, using the given HAL timer."]
    #[doc = ""]
    #[doc = " - __`timer`__: The timer to initialize. Cannot be NULL."]
    #[doc = " - __`fp`__:    The timer callback function. Cannot be NULL."]
    #[doc = " - __`arg`__:   Pointer to data object to pass to timer."]
    pub fn os_cputime_timer_init(timer: *mut hal_timer, fp: hal_timer_cb, arg: *mut ::cty::c_void);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Start a cputimer that will expire at 'cputime'. If cputime has already"]
    #[doc = " passed, the timer callback will still be called (at interrupt context)."]
    #[doc = ""]
    #[doc = " NOTE: This must be called when the timer is stopped."]
    #[doc = ""]
    #[doc = " - __`timer`__:     Pointer to timer to start. Cannot be NULL."]
    #[doc = " - __`cputime`__:   The cputime at which the timer should expire."]
    #[doc = ""]
    #[doc = " Return: int 0 on success; EINVAL if timer already started or timer struct"]
    #[doc = "         invalid"]
    #[doc = ""]
    pub fn os_cputime_timer_start(timer: *mut hal_timer, cputime: u32) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Sets a cpu timer that will expire 'usecs' microseconds from the current"]
    #[doc = " cputime."]
    #[doc = ""]
    #[doc = " NOTE: This must be called when the timer is stopped."]
    #[doc = ""]
    #[doc = " - __`timer`__: Pointer to timer. Cannot be NULL."]
    #[doc = " - __`usecs`__: The number of usecs from now at which the timer will expire."]
    #[doc = ""]
    #[doc = " Return: int 0 on success; EINVAL if timer already started or timer struct"]
    #[doc = "         invalid"]
    pub fn os_cputime_timer_relative(timer: *mut hal_timer, usecs: u32) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Stops a cputimer from running. The timer is removed from the timer queue"]
    #[doc = " and interrupts are disabled if no timers are left on the queue. Can be"]
    #[doc = " called even if timer is not running."]
    #[doc = ""]
    #[doc = " - __`timer`__: Pointer to cputimer to stop. Cannot be NULL."]
    pub fn os_cputime_timer_stop(timer: *mut hal_timer);
}
#[doc = " Initialize a device."]
#[doc = ""]
#[doc = " - __`dev`__: The device to initialize."]
#[doc = " - __`arg`__: User defined argument to pass to the device initalization"]
#[doc = ""]
#[doc = " Return: 0 on success, non-zero error code on failure."]
pub type os_dev_init_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut os_dev, arg2: *mut ::cty::c_void) -> ::cty::c_int,
>;
pub type os_dev_open_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut os_dev, arg2: u32, arg3: *mut ::cty::c_void) -> ::cty::c_int,
>;
pub type os_dev_suspend_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut os_dev, arg2: os_time_t, arg3: ::cty::c_int) -> ::cty::c_int,
>;
pub type os_dev_resume_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut os_dev) -> ::cty::c_int>;
pub type os_dev_close_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut os_dev) -> ::cty::c_int>;
#[doc = " Device handlers, implementers of device drivers should fill these"]
#[doc = " out to control device operation."]
#[repr(C)]
#[derive(Default)]
pub struct os_dev_handlers {
    #[doc = " Device open handler, called when the user opens the device."]
    #[doc = " Any locking of the device should be done within the open handler."]
    pub od_open: os_dev_open_func_t,
    #[doc = " Suspend handler, called when the device is being suspended."]
    #[doc = " Up to the implementer to save device state before power down,"]
    #[doc = " so that the device can be cleanly resumed -- or error out and"]
    #[doc = " delay suspension."]
    pub od_suspend: os_dev_suspend_func_t,
    #[doc = " Resume handler, restores device state after a suspend operation."]
    pub od_resume: os_dev_resume_func_t,
    #[doc = " Close handler, releases the device, including any locks that"]
    #[doc = " may have been taken by open()."]
    pub od_close: os_dev_close_func_t,
}
#[repr(C)]
pub struct os_dev {
    #[doc = " Device handlers.  Implementation of base device functions."]
    pub od_handlers: os_dev_handlers,
    #[doc = " Device initialization function."]
    pub od_init: os_dev_init_func_t,
    #[doc = " Argument to pass to device initialization function."]
    pub od_init_arg: *mut ::cty::c_void,
    #[doc = " Stage during which to initialize this device."]
    pub od_stage: u8,
    #[doc = " Priority within a given stage to initialize a device."]
    pub od_priority: u8,
    #[doc = " Number of references to a device being open before marking"]
    #[doc = " the device closed."]
    pub od_open_ref: u8,
    #[doc = " Device flags."]
    pub od_flags: u8,
    #[doc = " Device name"]
    pub od_name: *const ::cty::c_char,
    pub od_next: os_dev__bindgen_ty_1,
}
#[repr(C)]
pub struct os_dev__bindgen_ty_1 {
    pub stqe_next: *mut os_dev,
}
impl Default for os_dev__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_dev {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Suspend the operation of the device."]
    #[doc = ""]
    #[doc = " - __`dev`__: The device to suspend."]
    #[doc = " - __`suspend_t`__: When the device should be suspended."]
    #[doc = " - __`force`__: Whether not the suspend operation can be overridden by the"]
    #[doc = "        device handler."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn os_dev_suspend(dev: *mut os_dev, suspend_t: os_time_t, force: u8) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Resume the device operation."]
    #[doc = ""]
    #[doc = " - __`dev`__: The device to resume"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero error code on failure."]
    pub fn os_dev_resume(dev: *mut os_dev) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Create a new device in the kernel."]
    #[doc = ""]
    #[doc = " - __`dev`__: The device to create."]
    #[doc = " - __`name`__: The name of the device to create."]
    #[doc = " - __`stage`__: The stage to initialize that device to."]
    #[doc = " - __`priority`__: The priority of initializing that device"]
    #[doc = " - __`od_init`__: The initialization function to call for this"]
    #[doc = "                device."]
    #[doc = " - __`arg`__: The argument to provide this device initialization"]
    #[doc = "            function."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn os_dev_create(
        dev: *mut os_dev,
        name: *const ::cty::c_char,
        stage: u8,
        priority: u8,
        od_init: os_dev_init_func_t,
        arg: *mut ::cty::c_void,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Lookup a device by name."]
    #[doc = ""]
    #[doc = " WARNING: This should be called before any locking on the device is done, or"]
    #[doc = " the device list itself is modified in any context.  There is no locking."]
    #[doc = ""]
    #[doc = " - __`name`__: The name of the device to look up."]
    #[doc = ""]
    #[doc = " Return: A pointer to the device corresponding to name, or NULL if not found."]
    pub fn os_dev_lookup(name: *const ::cty::c_char) -> *mut os_dev;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize all devices for a given state."]
    #[doc = ""]
    #[doc = " - __`stage`__: The stage to initialize."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn os_dev_initialize_all(arg1: u8) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Suspend all devices."]
    #[doc = ""]
    #[doc = " - __`suspend_t`__: The number of ticks to suspend this device for"]
    #[doc = " - __`force`__: Whether or not to force suspending the device"]
    #[doc = ""]
    #[doc = " Return: 0 on success, or a non-zero error code if one of the devices"]
    #[doc = "                       returned it."]
    pub fn os_dev_suspend_all(arg1: os_time_t, arg2: u8) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Resume all the devices that were suspended."]
    #[doc = ""]
    #[doc = " Return: 0 on success, -1 if any of the devices have failed to resume."]
    pub fn os_dev_resume_all() -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Open a device."]
    #[doc = ""]
    #[doc = " - __`dev`__: The device to open"]
    #[doc = " - __`timo`__: The timeout to open the device, if not specified."]
    #[doc = " - __`arg`__: The argument to the device open() call."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn os_dev_open(
        devname: *const ::cty::c_char,
        timo: u32,
        arg: *mut ::cty::c_void,
    ) -> *mut os_dev;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Close a device."]
    #[doc = ""]
    #[doc = " - __`dev`__: The device to close"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn os_dev_close(dev: *mut os_dev) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Clears the device list.  This function does not close any devices or free"]
    #[doc = " any resources; its purpose is to allow a full system reset between unit"]
    #[doc = " tests."]
    pub fn os_dev_reset();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Walk through all devices, calling callback for every device."]
    #[doc = ""]
    #[doc = " - __`walk_func`__: Function to call"]
    #[doc = " @aparm arg       Argument to pass to walk_func"]
    pub fn os_dev_walk(
        walk_func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut os_dev, arg2: *mut ::cty::c_void) -> ::cty::c_int,
        >,
        arg: *mut ::cty::c_void,
    );
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Operating system level malloc().   This ensures that a safe malloc occurs"]
    #[doc = " within the context of the OS.  Depending on platform, the OS may rely on"]
    #[doc = " libc's malloc() implementation, which is not guaranteed to be thread-safe."]
    #[doc = " This malloc() will always be thread-safe."]
    #[doc = ""]
    #[doc = " - __`size`__: The number of bytes to allocate"]
    #[doc = ""]
    #[doc = " Return: A pointer to the memory region allocated."]
    pub fn os_malloc(size: usize) -> *mut ::cty::c_void;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Operating system level free().  See description of os_malloc() for reasoning."]
    #[doc = ""]
    #[doc = " Free's memory allocated by malloc."]
    #[doc = ""]
    #[doc = " - __`mem`__: The memory to free."]
    pub fn os_free(mem: *mut ::cty::c_void);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Operating system level realloc(). See description of os_malloc() for reasoning."]
    #[doc = ""]
    #[doc = " Reallocates the memory at ptr, to be size contiguouos bytes."]
    #[doc = ""]
    #[doc = " - __`ptr`__: A pointer to the memory to allocate"]
    #[doc = " - __`size`__: The number of contiguouos bytes to allocate at that location"]
    #[doc = ""]
    #[doc = " Return: A pointer to memory of size, or NULL on failure to allocate"]
    pub fn os_realloc(ptr: *mut ::cty::c_void, size: usize) -> *mut ::cty::c_void;
}
#[doc = " A mbuf pool from which to allocate mbufs. This contains a pointer to the os"]
#[doc = " mempool to allocate mbufs out of, the total number of elements in the pool,"]
#[doc = " and the amount of \"user\" data in a non-packet header mbuf. The total pool"]
#[doc = " size, in bytes, should be:"]
#[doc = "  os_mbuf_count * (omp_databuf_len + sizeof(struct os_mbuf))"]
#[repr(C)]
pub struct os_mbuf_pool {
    #[doc = " Total length of the databuf in each mbuf.  This is the size of the"]
    #[doc = " mempool block, minus the mbuf header"]
    pub omp_databuf_len: u16,
    #[doc = " The memory pool which to allocate mbufs out of"]
    pub omp_pool: *mut os_mempool,
    pub omp_next: os_mbuf_pool__bindgen_ty_1,
}
#[repr(C)]
pub struct os_mbuf_pool__bindgen_ty_1 {
    pub stqe_next: *mut os_mbuf_pool,
}
impl Default for os_mbuf_pool__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_mbuf_pool {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " A packet header structure that preceeds the mbuf packet headers."]
#[repr(C)]
pub struct os_mbuf_pkthdr {
    #[doc = " Overall length of the packet."]
    pub omp_len: u16,
    #[doc = " Flags"]
    pub omp_flags: u16,
    pub omp_next: os_mbuf_pkthdr__bindgen_ty_1,
}
#[repr(C)]
pub struct os_mbuf_pkthdr__bindgen_ty_1 {
    pub stqe_next: *mut os_mbuf_pkthdr,
}
impl Default for os_mbuf_pkthdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_mbuf_pkthdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Chained memory buffer."]
#[repr(C)]
pub struct os_mbuf {
    #[doc = " Current pointer to data in the structure"]
    pub om_data: *mut u8,
    #[doc = " Flags associated with this buffer, see OS_MBUF_F_* defintions"]
    pub om_flags: u8,
    #[doc = " Length of packet header"]
    pub om_pkthdr_len: u8,
    #[doc = " Length of data in this buffer"]
    pub om_len: u16,
    #[doc = " The mbuf pool this mbuf was allocated out of"]
    pub om_omp: *mut os_mbuf_pool,
    pub om_next: os_mbuf__bindgen_ty_1,
    #[doc = " Pointer to the beginning of the data, after this buffer"]
    pub om_databuf: __IncompleteArrayField<u8>,
}
#[repr(C)]
pub struct os_mbuf__bindgen_ty_1 {
    pub sle_next: *mut os_mbuf,
}
impl Default for os_mbuf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_mbuf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Structure representing a queue of mbufs."]
#[repr(C)]
pub struct os_mqueue {
    pub mq_head: os_mqueue__bindgen_ty_1,
    #[doc = " Event to post when new buffers are available on the queue."]
    pub mq_ev: os_event,
}
#[repr(C)]
pub struct os_mqueue__bindgen_ty_1 {
    pub stqh_first: *mut os_mbuf_pkthdr,
    pub stqh_last: *mut *mut os_mbuf_pkthdr,
}
impl Default for os_mqueue__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_mqueue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initializes an mqueue.  An mqueue is a queue of mbufs that ties to a"]
    #[doc = " particular task's event queue.  Mqueues form a helper API around a common"]
    #[doc = " paradigm: wait on an event queue until at least one packet is available,"]
    #[doc = " then process a queue of packets."]
    #[doc = ""]
    #[doc = " When mbufs are available on the queue, an event OS_EVENT_T_MQUEUE_DATA"]
    #[doc = " will be posted to the task's mbuf queue."]
    #[doc = ""]
    #[doc = " - __`mq`__:                    The mqueue to initialize"]
    #[doc = " - __`ev_cb`__:                 The callback to associate with the mqeueue"]
    #[doc = "                                  event.  Typically, this callback pulls each"]
    #[doc = "                                  packet off the mqueue and processes them."]
    #[doc = " - __`arg`__:                   The argument to associate with the mqueue event."]
    #[doc = ""]
    #[doc = " Return:                      0 on success, non-zero on failure."]
    pub fn os_mqueue_init(
        mq: *mut os_mqueue,
        ev_cb: os_event_fn,
        arg: *mut ::cty::c_void,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Remove and return a single mbuf from the mbuf queue.  Does not block."]
    #[doc = ""]
    #[doc = " - __`mq`__: The mbuf queue to pull an element off of."]
    #[doc = ""]
    #[doc = " Return: The next mbuf in the queue, or NULL if queue has no mbufs."]
    pub fn os_mqueue_get(arg1: *mut os_mqueue) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Adds a packet (i.e. packet header mbuf) to an mqueue. The event associated"]
    #[doc = " with the mqueue gets posted to the specified eventq."]
    #[doc = ""]
    #[doc = " - __`mq`__:                    The mbuf queue to append the mbuf to."]
    #[doc = " - __`evq`__:                   The event queue to post an event to."]
    #[doc = " - __`m`__:                     The mbuf to append to the mbuf queue."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn os_mqueue_put(
        arg1: *mut os_mqueue,
        arg2: *mut os_eventq,
        arg3: *mut os_mbuf,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " MSYS is a system level mbuf registry.  Allows the system to share"]
    #[doc = " packet buffers amongst the various networking stacks that can be running"]
    #[doc = " simultaeneously."]
    #[doc = ""]
    #[doc = " Mbuf pools are created in the system initialization code, and then when"]
    #[doc = " a mbuf is allocated out of msys, it will try and find the best fit based"]
    #[doc = " upon estimated mbuf size."]
    #[doc = ""]
    #[doc = " os_msys_register() registers a mbuf pool with MSYS, and allows MSYS to"]
    #[doc = " allocate mbufs out of it."]
    #[doc = ""]
    #[doc = " - __`new_pool`__: The pool to register with MSYS"]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure"]
    pub fn os_msys_register(arg1: *mut os_mbuf_pool) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Allocate a mbuf from msys.  Based upon the data size requested,"]
    #[doc = " os_msys_get() will choose the mbuf pool that has the best fit."]
    #[doc = ""]
    #[doc = " - __`dsize`__: The estimated size of the data being stored in the mbuf"]
    #[doc = " - __`leadingspace`__: The amount of leadingspace to allocate in the mbuf"]
    #[doc = ""]
    #[doc = " Return: A freshly allocated mbuf on success, NULL on failure."]
    pub fn os_msys_get(dsize: u16, leadingspace: u16) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " De-registers all mbuf pools from msys."]
    pub fn os_msys_reset();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Allocate a packet header structure from the MSYS pool.  See"]
    #[doc = " os_msys_register() for a description of MSYS."]
    #[doc = ""]
    #[doc = " - __`dsize`__: The estimated size of the data being stored in the mbuf"]
    #[doc = " - __`user_hdr_len`__: The length to allocate for the packet header structure"]
    #[doc = ""]
    #[doc = " Return: A freshly allocated mbuf on success, NULL on failure."]
    pub fn os_msys_get_pkthdr(dsize: u16, user_hdr_len: u16) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Count the number of blocks in all the mbuf pools that are allocated."]
    #[doc = ""]
    #[doc = " Return: total number of blocks allocated in Msys"]
    pub fn os_msys_count() -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Return the number of free blocks in Msys"]
    #[doc = ""]
    #[doc = " Return: Number of free blocks available in Msys"]
    pub fn os_msys_num_free() -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a pool of mbufs."]
    #[doc = ""]
    #[doc = " - __`omp`__:     The mbuf pool to initialize"]
    #[doc = " - __`mp`__:      The memory pool that will hold this mbuf pool"]
    #[doc = " - __`buf_len`__: The length of the buffer itself."]
    #[doc = " - __`nbufs`__:   The number of buffers in the pool"]
    #[doc = ""]
    #[doc = " Return: 0 on success, error code on failure."]
    pub fn os_mbuf_pool_init(
        arg1: *mut os_mbuf_pool,
        mp: *mut os_mempool,
        arg2: u16,
        arg3: u16,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get an mbuf from the mbuf pool.  The mbuf is allocated, and initialized"]
    #[doc = " prior to being returned."]
    #[doc = ""]
    #[doc = " - __`omp`__: The mbuf pool to return the packet from"]
    #[doc = " - __`leadingspace`__: The amount of leadingspace to put before the data"]
    #[doc = "     section by default."]
    #[doc = ""]
    #[doc = " Return: An initialized mbuf on success, and NULL on failure."]
    pub fn os_mbuf_get(omp: *mut os_mbuf_pool, arg1: u16) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Allocate a new packet header mbuf out of the os_mbuf_pool."]
    #[doc = ""]
    #[doc = " - __`omp`__: The mbuf pool to allocate out of"]
    #[doc = " - __`user_pkthdr_len`__: The packet header length to reserve for the caller."]
    #[doc = ""]
    #[doc = " Return: A freshly allocated mbuf on success, NULL on failure."]
    pub fn os_mbuf_get_pkthdr(omp: *mut os_mbuf_pool, pkthdr_len: u8) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Duplicate a chain of mbufs.  Return the start of the duplicated chain."]
    #[doc = ""]
    #[doc = " - __`omp`__: The mbuf pool to duplicate out of"]
    #[doc = " - __`om`__:  The mbuf chain to duplicate"]
    #[doc = ""]
    #[doc = " Return: A pointer to the new chain of mbufs"]
    pub fn os_mbuf_dup(m: *mut os_mbuf) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Locates the specified absolute offset within an mbuf chain.  The offset"]
    #[doc = " can be one past than the total length of the chain, but no greater."]
    #[doc = ""]
    #[doc = " - __`om`__:                    The start of the mbuf chain to seek within."]
    #[doc = " - __`off`__:                   The absolute address to find."]
    #[doc = " - __`out_off`__:               On success, this points to the relative offset"]
    #[doc = "                                  within the returned mbuf."]
    #[doc = ""]
    #[doc = " Return:                      The mbuf containing the specified offset on"]
    #[doc = "                                  success."]
    #[doc = "                              NULL if the specified offset is out of bounds."]
    pub fn os_mbuf_off(om: *const os_mbuf, off: ::cty::c_int, out_off: *mut u16) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_mbuf_copydata(
        m: *const os_mbuf,
        off: ::cty::c_int,
        len: ::cty::c_int,
        dst: *mut ::cty::c_void,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @brief Calculates the length of an mbuf chain."]
    #[doc = ""]
    #[doc = " Calculates the length of an mbuf chain.  If the mbuf contains a packet"]
    #[doc = " header, you should use `OS_MBUF_PKTLEN()` as a more efficient alternative to"]
    #[doc = " this function."]
    #[doc = ""]
    #[doc = " - __`om`__:                    The mbuf to measure."]
    #[doc = ""]
    #[doc = " Return:                      The length, in bytes, of the provided mbuf"]
    #[doc = "                                  chain."]
    pub fn os_mbuf_len(om: *const os_mbuf) -> u16;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Append data onto a mbuf"]
    #[doc = ""]
    #[doc = " - __`om`__:   The mbuf to append the data onto"]
    #[doc = " - __`data`__: The data to append onto the mbuf"]
    #[doc = " - __`len`__:  The length of the data to append"]
    #[doc = ""]
    #[doc = " Return: 0 on success, and an error code on failure"]
    pub fn os_mbuf_append(m: *mut os_mbuf, arg1: *const ::cty::c_void, arg2: u16) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reads data from one mbuf and appends it to another.  On error, the specified"]
    #[doc = " data range may be partially appended.  Neither mbuf is required to contain"]
    #[doc = " an mbuf packet header."]
    #[doc = ""]
    #[doc = " - __`dst`__:                   The mbuf to append to."]
    #[doc = " - __`src`__:                   The mbuf to copy data from."]
    #[doc = " - __`src_off`__:               The absolute offset within the source mbuf"]
    #[doc = "                                  chain to read from."]
    #[doc = " - __`len`__:                   The number of bytes to append."]
    #[doc = ""]
    #[doc = " Return:                      0 on success;"]
    #[doc = "                              OS_EINVAL if the specified range extends beyond"]
    #[doc = "                                  the end of the source mbuf chain."]
    pub fn os_mbuf_appendfrom(
        dst: *mut os_mbuf,
        src: *const os_mbuf,
        src_off: u16,
        len: u16,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Release a mbuf back to the pool"]
    #[doc = ""]
    #[doc = " - __`omp`__: The Mbuf pool to release back to"]
    #[doc = " - __`om`__:  The Mbuf to release back to the pool"]
    #[doc = ""]
    #[doc = " Return: 0 on success, -1 on failure"]
    pub fn os_mbuf_free(mb: *mut os_mbuf) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Free a chain of mbufs"]
    #[doc = ""]
    #[doc = " - __`omp`__: The mbuf pool to free the chain of mbufs into"]
    #[doc = " - __`om`__:  The starting mbuf of the chain to free back into the pool"]
    #[doc = ""]
    #[doc = " Return: 0 on success, -1 on failure"]
    pub fn os_mbuf_free_chain(om: *mut os_mbuf) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Adjust the length of a mbuf, trimming either from the head or the tail"]
    #[doc = " of the mbuf."]
    #[doc = ""]
    #[doc = " - __`mp`__: The mbuf chain to adjust"]
    #[doc = " - __`req_len`__: The length to trim from the mbuf.  If positive, trims"]
    #[doc = "                from the head of the mbuf, if negative, trims from the"]
    #[doc = "                tail of the mbuf."]
    pub fn os_mbuf_adj(mp: *mut os_mbuf, req_len: ::cty::c_int);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Performs a memory compare of the specified region of an mbuf chain against a"]
    #[doc = " flat buffer."]
    #[doc = ""]
    #[doc = " - __`om`__:                    The start of the mbuf chain to compare."]
    #[doc = " - __`off`__:                   The offset within the mbuf chain to start the"]
    #[doc = "                                  comparison."]
    #[doc = " - __`data`__:                  The flat buffer to compare."]
    #[doc = " - __`len`__:                   The length of the flat buffer."]
    #[doc = ""]
    #[doc = " Return:                      0 if both memory regions are identical;"]
    #[doc = "                              A memcmp return code if there is a mismatch;"]
    #[doc = "                              INT_MAX if the mbuf is too short."]
    pub fn os_mbuf_cmpf(
        om: *const os_mbuf,
        off: ::cty::c_int,
        data: *const ::cty::c_void,
        len: ::cty::c_int,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Compares the contents of two mbuf chains.  The ranges of the two chains to"]
    #[doc = " be compared are specified via the two offset parameters and the len"]
    #[doc = " parameter.  Neither mbuf chain is required to contain a packet header."]
    #[doc = ""]
    #[doc = " - __`om1`__:                   The first mbuf chain to compare."]
    #[doc = " - __`offset1`__:               The absolute offset within om1 at which to"]
    #[doc = "                                  start the comparison."]
    #[doc = " - __`om2`__:                   The second mbuf chain to compare."]
    #[doc = " - __`offset2`__:               The absolute offset within om2 at which to"]
    #[doc = "                                  start the comparison."]
    #[doc = " - __`len`__:                   The number of bytes to compare."]
    #[doc = ""]
    #[doc = " Return:                      0 if both mbuf segments are identical;"]
    #[doc = "                              A memcmp() return code if the segment contents"]
    #[doc = "                                  differ;"]
    #[doc = "                              INT_MAX if a specified range extends beyond the"]
    #[doc = "                                  end of its corresponding mbuf chain."]
    pub fn os_mbuf_cmpm(
        om1: *const os_mbuf,
        offset1: u16,
        om2: *const os_mbuf,
        offset2: u16,
        len: u16,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Increases the length of an mbuf chain by adding data to the front.  If there"]
    #[doc = " is insufficient room in the leading mbuf, additional mbufs are allocated and"]
    #[doc = " prepended as necessary.  If this function fails to allocate an mbuf, the"]
    #[doc = " entire chain is freed."]
    #[doc = ""]
    #[doc = " The specified mbuf chain does not need to contain a packet header."]
    #[doc = ""]
    #[doc = " - __`omp`__:                   The mbuf pool to allocate from."]
    #[doc = " - __`om`__:                    The head of the mbuf chain."]
    #[doc = " - __`len`__:                   The number of bytes to prepend."]
    #[doc = ""]
    #[doc = " Return:                      The new head of the chain on success;"]
    #[doc = "                              NULL on failure."]
    pub fn os_mbuf_prepend(om: *mut os_mbuf, len: ::cty::c_int) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Prepends a chunk of empty data to the specified mbuf chain and ensures the"]
    #[doc = " chunk is contiguous.  If either operation fails, the specified mbuf chain is"]
    #[doc = " freed and NULL is returned."]
    #[doc = ""]
    #[doc = " - __`om`__:                    The mbuf chain to prepend to."]
    #[doc = " - __`len`__:                   The number of bytes to prepend and pullup."]
    #[doc = ""]
    #[doc = " Return:                      The modified mbuf on success;"]
    #[doc = "                              NULL on failure (and the mbuf chain is freed)."]
    pub fn os_mbuf_prepend_pullup(om: *mut os_mbuf, len: u16) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Copies the contents of a flat buffer into an mbuf chain, starting at the"]
    #[doc = " specified destination offset.  If the mbuf is too small for the source data,"]
    #[doc = " it is extended as necessary.  If the destination mbuf contains a packet"]
    #[doc = " header, the header length is updated."]
    #[doc = ""]
    #[doc = " - __`omp`__:                   The mbuf pool to allocate from."]
    #[doc = " - __`om`__:                    The mbuf chain to copy into."]
    #[doc = " - __`off`__:                   The offset within the chain to copy to."]
    #[doc = " - __`src`__:                   The source buffer to copy from."]
    #[doc = " - __`len`__:                   The number of bytes to copy."]
    #[doc = ""]
    #[doc = " Return:                      0 on success; nonzero on failure."]
    pub fn os_mbuf_copyinto(
        om: *mut os_mbuf,
        off: ::cty::c_int,
        src: *const ::cty::c_void,
        len: ::cty::c_int,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Attaches a second mbuf chain onto the end of the first.  If the first chain"]
    #[doc = " contains a packet header, the header's length is updated.  If the second"]
    #[doc = " chain has a packet header, its header is cleared."]
    #[doc = ""]
    #[doc = " - __`first`__:                 The mbuf chain being attached to."]
    #[doc = " - __`second`__:                The mbuf chain that gets attached."]
    pub fn os_mbuf_concat(first: *mut os_mbuf, second: *mut os_mbuf);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Increases the length of an mbuf chain by the specified amount.  If there is"]
    #[doc = " not sufficient room in the last buffer, a new buffer is allocated and"]
    #[doc = " appended to the chain.  It is an error to request more data than can fit in"]
    #[doc = " a single buffer."]
    #[doc = ""]
    #[doc = " @param omp"]
    #[doc = " - __`om`__:                    The head of the chain to extend."]
    #[doc = " - __`len`__:                   The number of bytes to extend by."]
    #[doc = ""]
    #[doc = " Return:                      A pointer to the new data on success;"]
    #[doc = "                              NULL on failure."]
    pub fn os_mbuf_extend(om: *mut os_mbuf, len: u16) -> *mut ::cty::c_void;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Rearrange a mbuf chain so that len bytes are contiguous,"]
    #[doc = " and in the data area of an mbuf (so that OS_MBUF_DATA() will"]
    #[doc = " work on a structure of size len.)  Returns the resulting"]
    #[doc = " mbuf chain on success, free's it and returns NULL on failure."]
    #[doc = ""]
    #[doc = " If there is room, it will add up to \"max_protohdr - len\""]
    #[doc = " extra bytes to the contiguous region, in an attempt to avoid being"]
    #[doc = " called next time."]
    #[doc = ""]
    #[doc = " - __`omp`__: The mbuf pool to take the mbufs out of"]
    #[doc = " - __`om`__: The mbuf chain to make contiguous"]
    #[doc = " - __`len`__: The number of bytes in the chain to make contiguous"]
    #[doc = ""]
    #[doc = " Return: The contiguous mbuf chain on success, NULL on failure."]
    pub fn os_mbuf_pullup(om: *mut os_mbuf, len: u16) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Removes and frees empty mbufs from the front of a chain.  If the chain"]
    #[doc = " contains a packet header, it is preserved."]
    #[doc = ""]
    #[doc = " - __`om`__:                    The mbuf chain to trim."]
    #[doc = ""]
    #[doc = " Return:                      The head of the trimmed mbuf chain."]
    pub fn os_mbuf_trim_front(om: *mut os_mbuf) -> *mut os_mbuf;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Increases the length of an mbuf chain by inserting a gap at the specified"]
    #[doc = " offset.  The contents of the gap are indeterminate.  If the mbuf chain"]
    #[doc = " contains a packet header, its total length is increased accordingly."]
    #[doc = ""]
    #[doc = " This function never frees the provided mbuf chain."]
    #[doc = ""]
    #[doc = " - __`om`__:                    The mbuf chain to widen."]
    #[doc = " - __`off`__:                   The offset at which to insert the gap."]
    #[doc = " - __`len`__:                   The size of the gap to insert."]
    #[doc = ""]
    #[doc = " Return:                      0 on success; SYS_[...] error code on failure."]
    pub fn os_mbuf_widen(om: *mut os_mbuf, off: u16, len: u16) -> ::cty::c_int;
}
#[doc = " A memory block structure. This simply contains a pointer to the free list"]
#[doc = " chain and is only used when the block is on the free list. When the block"]
#[doc = " has been removed from the free list the entire memory block is usable by the"]
#[doc = " caller."]
#[repr(C)]
pub struct os_memblock {
    pub mb_next: os_memblock__bindgen_ty_1,
}
#[repr(C)]
pub struct os_memblock__bindgen_ty_1 {
    pub sle_next: *mut os_memblock,
}
impl Default for os_memblock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_memblock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Memory pool"]
#[repr(C)]
pub struct os_mempool {
    #[doc = " Size of the memory blocks, in bytes."]
    pub mp_block_size: u32,
    #[doc = " The number of memory blocks."]
    pub mp_num_blocks: u16,
    #[doc = " The number of free blocks left"]
    pub mp_num_free: u16,
    #[doc = " The lowest number of free blocks seen"]
    pub mp_min_free: u16,
    #[doc = " Bitmap of OS_MEMPOOL_F_[...] values."]
    pub mp_flags: u8,
    #[doc = " Address of memory buffer used by pool"]
    pub mp_membuf_addr: u32,
    pub mp_list: os_mempool__bindgen_ty_1,
    pub __bindgen_anon_1: os_mempool__bindgen_ty_2,
    #[doc = " Name for memory block"]
    pub name: *mut ::cty::c_char,
}
#[repr(C)]
pub struct os_mempool__bindgen_ty_1 {
    pub stqe_next: *mut os_mempool,
}
impl Default for os_mempool__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_mempool__bindgen_ty_2 {
    pub slh_first: *mut os_memblock,
}
impl Default for os_mempool__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_mempool {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Block put callback function.  If configured, this callback gets executed"]
#[doc = " whenever a block is freed to the corresponding extended mempool.  Note: The"]
#[doc = " os_memblock_put() function calls this callback instead of freeing the block"]
#[doc = " itself.  Therefore, it is the callback's responsibility to free the block"]
#[doc = " via a call to os_memblock_put_from_cb()."]
#[doc = ""]
#[doc = " - __`ome`__:                   The extended mempool that a block is being"]
#[doc = "                                  freed back to."]
#[doc = " - __`data`__:                  The block being freed."]
#[doc = " - __`arg`__:                   Optional argument configured along with the"]
#[doc = "                                  callback."]
#[doc = ""]
#[doc = " Return:                      Indicates whether the block was successfully"]
#[doc = "                                  freed.  A non-zero value should only be"]
#[doc = "                                  returned if the block was not successfully"]
#[doc = "                                  released back to its pool."]
pub type os_mempool_put_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ome: *mut os_mempool_ext,
        data: *mut ::cty::c_void,
        arg: *mut ::cty::c_void,
    ) -> os_error_t,
>;
#[repr(C)]
pub struct os_mempool_ext {
    pub mpe_mp: os_mempool,
    pub mpe_put_cb: os_mempool_put_fn,
    pub mpe_put_arg: *mut ::cty::c_void,
}
impl Default for os_mempool_ext {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Information describing a memory pool, used to return OS information"]
#[doc = " to the management layer."]
#[repr(C)]
#[derive(Default)]
pub struct os_mempool_info {
    #[doc = " Size of the memory blocks in the pool"]
    pub omi_block_size: ::cty::c_int,
    #[doc = " Number of memory blocks in the pool"]
    pub omi_num_blocks: ::cty::c_int,
    #[doc = " Number of free memory blocks"]
    pub omi_num_free: ::cty::c_int,
    #[doc = " Minimum number of free memory blocks ever"]
    pub omi_min_free: ::cty::c_int,
    #[doc = " Name of the memory pool"]
    pub omi_name: [::cty::c_char; 32usize],
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get information about the next system memory pool."]
    #[doc = ""]
    #[doc = " - __`mempool`__: The current memory pool, or NULL if starting iteration."]
    #[doc = " - __`info`__:    A pointer to the structure to return memory pool information"]
    #[doc = "                into."]
    #[doc = ""]
    #[doc = " Return: The next memory pool in the list to get information about, or NULL"]
    #[doc = "         when at the last memory pool."]
    pub fn os_mempool_info_get_next(
        arg1: *mut os_mempool,
        arg2: *mut os_mempool_info,
    ) -> *mut os_mempool;
}
pub type os_membuf_t = u32;
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a memory pool."]
    #[doc = ""]
    #[doc = " - __`mp`__:            Pointer to a pointer to a mempool"]
    #[doc = " - __`blocks`__:        The number of blocks in the pool"]
    #[doc = " - __`blocks_size`__:   The size of the block, in bytes."]
    #[doc = " - __`membuf`__:        Pointer to memory to contain blocks."]
    #[doc = " - __`name`__:          Name of the pool."]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    pub fn os_mempool_init(
        mp: *mut os_mempool,
        blocks: u16,
        block_size: u32,
        membuf: *mut ::cty::c_void,
        name: *mut ::cty::c_char,
    ) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initializes an extended memory pool.  Extended attributes (e.g., callbacks)"]
    #[doc = " are not specified when this function is called; they are assigned manually"]
    #[doc = " after initialization."]
    #[doc = ""]
    #[doc = " - __`mpe`__:           The extended memory pool to initialize."]
    #[doc = " - __`blocks`__:        The number of blocks in the pool."]
    #[doc = " - __`block_size`__:    The size of each block, in bytes."]
    #[doc = " - __`membuf`__:        Pointer to memory to contain blocks."]
    #[doc = " - __`name`__:          Name of the pool."]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    pub fn os_mempool_ext_init(
        mpe: *mut os_mempool_ext,
        blocks: u16,
        block_size: u32,
        membuf: *mut ::cty::c_void,
        name: *mut ::cty::c_char,
    ) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Removes the specified mempool from the list of initialized mempools."]
    #[doc = ""]
    #[doc = " - __`mp`__:                    The mempool to unregister."]
    #[doc = ""]
    #[doc = " Return:                      0 on success;"]
    #[doc = "                              OS_INVALID_PARM if the mempool is not"]
    #[doc = "                                  registered."]
    pub fn os_mempool_unregister(mp: *mut os_mempool) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Clears a memory pool."]
    #[doc = ""]
    #[doc = " - __`mp`__:            The mempool to clear."]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    pub fn os_mempool_clear(mp: *mut os_mempool) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_mempool_is_sane(mp: *const os_mempool) -> bool;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Checks if a memory block was allocated from the specified mempool."]
    #[doc = ""]
    #[doc = " - __`mp`__:                    The mempool to check as parent."]
    #[doc = " - __`block_addr`__:            The memory block to check as child."]
    #[doc = ""]
    #[doc = " Return:                      0 if the block does not belong to the mempool;"]
    #[doc = "                              1 if the block does belong to the mempool."]
    pub fn os_memblock_from(
        mp: *const os_mempool,
        block_addr: *const ::cty::c_void,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get a memory block from a memory pool"]
    #[doc = ""]
    #[doc = " - __`mp`__: Pointer to the memory pool"]
    #[doc = ""]
    #[doc = " Return: void* Pointer to block if available; NULL otherwise"]
    pub fn os_memblock_get(mp: *mut os_mempool) -> *mut ::cty::c_void;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Puts the memory block back into the pool, ignoring the put callback, if any."]
    #[doc = " This function should only be called from a put callback to free a block"]
    #[doc = " without causing infinite recursion."]
    #[doc = ""]
    #[doc = " - __`mp`__: Pointer to memory pool"]
    #[doc = " - __`block_addr`__: Pointer to memory block"]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    pub fn os_memblock_put_from_cb(
        mp: *mut os_mempool,
        block_addr: *mut ::cty::c_void,
    ) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Puts the memory block back into the pool"]
    #[doc = ""]
    #[doc = " - __`mp`__: Pointer to memory pool"]
    #[doc = " - __`block_addr`__: Pointer to memory block"]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    pub fn os_memblock_put(mp: *mut os_mempool, block_addr: *mut ::cty::c_void) -> os_error_t;
}
#[doc = " OS mutex structure"]
#[repr(C)]
pub struct os_mutex {
    pub mu_head: os_mutex__bindgen_ty_1,
    pub _pad: u8,
    #[doc = " Mutex owner's default priority"]
    pub mu_prio: u8,
    #[doc = " Mutex call nesting level"]
    pub mu_level: u16,
    #[doc = " Task that owns the mutex"]
    pub mu_owner: *mut os_task,
}
#[repr(C)]
pub struct os_mutex__bindgen_ty_1 {
    pub slh_first: *mut os_task,
}
impl Default for os_mutex__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_mutex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Create a mutex and initialize it."]
    #[doc = ""]
    #[doc = " - __`mu`__: Pointer to mutex"]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    #[doc = "      OS_INVALID_PARM     Mutex passed in was NULL."]
    #[doc = "      OS_OK               no error."]
    pub fn os_mutex_init(mu: *mut os_mutex) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Release a mutex."]
    #[doc = ""]
    #[doc = " - __`mu`__: Pointer to the mutex to be released"]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    #[doc = "      OS_INVALID_PARM Mutex passed in was NULL."]
    #[doc = "      OS_BAD_MUTEX    Mutex was not granted to current task (not owner)."]
    #[doc = "      OS_OK           No error"]
    pub fn os_mutex_release(mu: *mut os_mutex) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Pend (wait) for a mutex."]
    #[doc = ""]
    #[doc = " - __`mu`__: Pointer to mutex."]
    #[doc = " - __`timeout`__: Timeout, in os ticks."]
    #[doc = "                A timeout of 0 means do not wait if not available."]
    #[doc = "                A timeout of OS_TIMEOUT_NEVER means wait forever."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    #[doc = "      OS_INVALID_PARM     Mutex passed in was NULL."]
    #[doc = "      OS_TIMEOUT          Mutex was owned by another task and timeout=0"]
    #[doc = "      OS_OK               no error."]
    pub fn os_mutex_pend(mu: *mut os_mutex, timeout: os_time_t) -> os_error_t;
}
pub type os_sanity_check_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut os_sanity_check, arg2: *mut ::cty::c_void) -> ::cty::c_int,
>;
#[repr(C)]
pub struct os_sanity_check {
    #[doc = " Time this check last ran successfully."]
    pub sc_checkin_last: os_time_t,
    #[doc = " Interval this task should check in at"]
    pub sc_checkin_itvl: os_time_t,
    #[doc = " Sanity check to run"]
    pub sc_func: os_sanity_check_func_t,
    #[doc = " Argument to pass to sanity check"]
    pub sc_arg: *mut ::cty::c_void,
    pub sc_next: os_sanity_check__bindgen_ty_1,
}
#[repr(C)]
pub struct os_sanity_check__bindgen_ty_1 {
    pub sle_next: *mut os_sanity_check,
}
impl Default for os_sanity_check__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_sanity_check {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @cond INTERNAL_HIDDEN"]
    pub fn os_sanity_init() -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sanity_run();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Provide a \"task checkin\" for the sanity task."]
    #[doc = ""]
    #[doc = " - __`t`__: The task to check in"]
    #[doc = ""]
    #[doc = " Return: 0 on success, error code on failure"]
    pub fn os_sanity_task_checkin(arg1: *mut os_task) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a sanity check"]
    #[doc = ""]
    #[doc = " - __`sc`__: The sanity check to initialize"]
    #[doc = ""]
    #[doc = " Return: 0 on success, error code on failure."]
    pub fn os_sanity_check_init(arg1: *mut os_sanity_check) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Register a sanity check"]
    #[doc = ""]
    #[doc = " - __`sc`__: The sanity check to register"]
    #[doc = ""]
    #[doc = " Return: 0 on success, error code on failure"]
    pub fn os_sanity_check_register(arg1: *mut os_sanity_check) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reset the os sanity check, so that it doesn't trip up the"]
    #[doc = " sanity timer."]
    #[doc = ""]
    #[doc = " - __`sc`__: The sanity check to reset"]
    #[doc = ""]
    #[doc = " Return: 0 on success, error code on failure"]
    pub fn os_sanity_check_reset(arg1: *mut os_sanity_check) -> ::cty::c_int;
}
#[repr(C)]
pub struct os_task_obj {
    pub obj_head: os_task_obj__bindgen_ty_1,
}
#[repr(C)]
pub struct os_task_obj__bindgen_ty_1 {
    pub slh_first: *mut os_task,
}
impl Default for os_task_obj__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_task_obj {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Task is ready to run"]
pub const os_task_state_OS_TASK_READY: os_task_state = 1;
#[doc = " Task is sleeping"]
pub const os_task_state_OS_TASK_SLEEP: os_task_state = 2;
#[doc = " Task states"]
pub type os_task_state = u32;
pub use self::os_task_state as os_task_state_t;
pub type os_task_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::cty::c_void)>;
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
pub struct os_task {
    #[doc = " Current stack pointer for this task"]
    pub t_stackptr: *mut os_stack_t,
    #[doc = " Pointer to top of this task's stack"]
    pub t_stacktop: *mut os_stack_t,
    #[doc = " Size of this task's stack"]
    pub t_stacksize: u16,
    #[doc = " Task ID"]
    pub t_taskid: u8,
    #[doc = " Task Priority"]
    pub t_prio: u8,
    pub t_state: u8,
    #[doc = " Task flags, bitmask"]
    pub t_flags: u8,
    pub t_lockcnt: u8,
    pub t_pad: u8,
    #[doc = " Task name"]
    pub t_name: *const ::cty::c_char,
    #[doc = " Task function that executes"]
    pub t_func: os_task_func_t,
    #[doc = " Argument to pass to task function when called"]
    pub t_arg: *mut ::cty::c_void,
    #[doc = " Current object task is waiting on, either a semaphore or mutex"]
    pub t_obj: *mut ::cty::c_void,
    #[doc = " Default sanity check for this task"]
    pub t_sanity_check: os_sanity_check,
    #[doc = " Next scheduled wakeup if this task is sleeping"]
    pub t_next_wakeup: os_time_t,
    #[doc = " Total task run time"]
    pub t_run_time: os_time_t,
    #[doc = " Total number of times this task has been context switched during"]
    #[doc = " execution."]
    pub t_ctx_sw_cnt: u32,
    pub t_os_task_list: os_task__bindgen_ty_1,
    pub t_os_list: os_task__bindgen_ty_2,
    pub t_obj_list: os_task__bindgen_ty_3,
}
#[repr(C)]
pub struct os_task__bindgen_ty_1 {
    pub stqe_next: *mut os_task,
}
impl Default for os_task__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_task__bindgen_ty_2 {
    pub tqe_next: *mut os_task,
    pub tqe_prev: *mut *mut os_task,
}
impl Default for os_task__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct os_task__bindgen_ty_3 {
    pub sle_next: *mut os_task,
}
impl Default for os_task__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_task {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
pub struct os_task_stailq {
    pub stqh_first: *mut os_task,
    pub stqh_last: *mut *mut os_task,
}
impl Default for os_task_stailq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a task."]
    #[doc = ""]
    #[doc = " This function initializes the task structure pointed to by t,"]
    #[doc = " clearing and setting it's stack pointer, provides sane defaults"]
    #[doc = " and sets the task as ready to run, and inserts it into the operating"]
    #[doc = " system scheduler."]
    #[doc = ""]
    #[doc = " - __`t`__: The task to initialize"]
    #[doc = " - __`name`__: The name of the task to initialize"]
    #[doc = " - __`func`__: The task function to call"]
    #[doc = " - __`arg`__: The argument to pass to this task function"]
    #[doc = " - __`prio`__: The priority at which to run this task"]
    #[doc = " - __`sanity_itvl`__: The time at which this task should check in with the"]
    #[doc = "                    sanity task.  OS_WAIT_FOREVER means never check in"]
    #[doc = "                    here."]
    #[doc = " - __`stack_bottom`__: A pointer to the bottom of a task's stack"]
    #[doc = " - __`stack_size`__: The overall size of the task's stack."]
    #[doc = ""]
    #[doc = " Return: 0 on success, non-zero on failure."]
    pub fn os_task_init(
        arg1: *mut os_task,
        arg2: *const ::cty::c_char,
        arg3: os_task_func_t,
        arg4: *mut ::cty::c_void,
        arg5: u8,
        arg6: os_time_t,
        arg7: *mut os_stack_t,
        arg8: u16,
    ) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Removes specified task"]
    #[doc = " XXX"]
    #[doc = " NOTE: This interface is currently experimental and not ready for common use"]
    pub fn os_task_remove(t: *mut os_task) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Return the number of tasks initialized."]
    #[doc = ""]
    #[doc = " Return: number of tasks initialized"]
    pub fn os_task_count() -> u8;
}
#[doc = " Information about an individual task, returned for management APIs."]
#[repr(C)]
#[derive(Default)]
pub struct os_task_info {
    #[doc = " Task priority"]
    pub oti_prio: u8,
    #[doc = " Task identifier"]
    pub oti_taskid: u8,
    #[doc = " Task state, either READY or SLEEP"]
    pub oti_state: u8,
    #[doc = " Task stack usage"]
    pub oti_stkusage: u16,
    #[doc = " Task stack size"]
    pub oti_stksize: u16,
    #[doc = " Task context switch count"]
    pub oti_cswcnt: u32,
    #[doc = " Task runtime"]
    pub oti_runtime: u32,
    #[doc = " Last time this task checked in with sanity"]
    pub oti_last_checkin: os_time_t,
    #[doc = " Next time this task is scheduled to check-in with sanity"]
    pub oti_next_checkin: os_time_t,
    #[doc = " Name of this task"]
    pub oti_name: [::cty::c_char; 32usize],
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Iterate through tasks, and return the following information about them:"]
    #[doc = ""]
    #[doc = " - Priority"]
    #[doc = " - Task ID"]
    #[doc = " - State (READY, SLEEP)"]
    #[doc = " - Total Stack Usage"]
    #[doc = " - Stack Size"]
    #[doc = " - Context Switch Count"]
    #[doc = " - Runtime"]
    #[doc = " - Last & Next Sanity checkin"]
    #[doc = " - Task Name"]
    #[doc = ""]
    #[doc = " To get the first task in the list, call os_task_info_get_next() with a"]
    #[doc = " NULL pointer in the prev argument, and os_task_info_get_next() will"]
    #[doc = " return a pointer to the task structure, and fill out the os_task_info"]
    #[doc = " structure pointed to by oti."]
    #[doc = ""]
    #[doc = " To get the next task in the list, provide the task structure returned"]
    #[doc = " by the previous call to os_task_info_get_next(), and os_task_info_get_next()"]
    #[doc = " will fill out the task structure pointed to by oti again, and return"]
    #[doc = " the next task in the list."]
    #[doc = ""]
    #[doc = " - __`prev`__: The previous task returned by os_task_info_get_next(), or NULL"]
    #[doc = "             to begin iteration."]
    #[doc = " - __`oti`__:  The OS task info structure to fill out."]
    #[doc = ""]
    #[doc = " Return: A pointer to the OS task that has been read, or NULL when finished"]
    #[doc = "         iterating through all tasks."]
    pub fn os_task_info_get_next(arg1: *const os_task, arg2: *mut os_task_info) -> *mut os_task;
}
#[repr(C)]
pub struct os_task_list {
    pub tqh_first: *mut os_task,
    pub tqh_last: *mut *mut os_task,
}
impl Default for os_task_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_ctx_sw_hook(arg1: *mut os_task);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Returns the currently running task. Note that this task may or may not be"]
    #[doc = " the highest priority task ready to run."]
    #[doc = ""]
    #[doc = " Return: The currently running task."]
    pub fn os_sched_get_current_task() -> *mut os_task;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_set_current_task(arg1: *mut os_task);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_next_task() -> *mut os_task;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Performs context switch if needed. If next_t is set, that task will be made"]
    #[doc = " running. If next_t is NULL, highest priority ready to run is swapped in. This"]
    #[doc = " function can be called when new tasks were made ready to run or if the current"]
    #[doc = " task is moved to sleeping state."]
    #[doc = ""]
    #[doc = " This function will call the architecture specific routine to swap in the new task."]
    #[doc = ""]
    #[doc = " - __`next_t`__: Pointer to task which must run next (optional)"]
    #[doc = ""]
    #[doc = " Return: n/a"]
    #[doc = ""]
    #[doc = " __Note:__ Interrupts must be disabled when calling this."]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " // example"]
    #[doc = " os_error_t"]
    #[doc = " os_mutex_release(struct os_mutex *mu)"]
    #[doc = " {"]
    #[doc = "     ..."]
    #[doc = "     OS_EXIT_CRITICAL(sr);"]
    #[doc = ""]
    #[doc = "     // Re-schedule if needed"]
    #[doc = "     if (resched) {"]
    #[doc = "         os_sched(rdy);"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     return OS_OK;"]
    #[doc = ""]
    #[doc = " }"]
    #[doc = " ```"]
    pub fn os_sched(arg1: *mut os_task);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @cond INTERNAL_HIDDEN"]
    pub fn os_sched_os_timer_exp();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_insert(arg1: *mut os_task) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_sleep(arg1: *mut os_task, nticks: os_time_t) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_wakeup(arg1: *mut os_task) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_remove(arg1: *mut os_task) -> ::cty::c_int;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_resort(arg1: *mut os_task);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_sched_wakeup_ticks(now: os_time_t) -> os_time_t;
}
#[doc = " Structure representing an OS semaphore."]
#[repr(C)]
pub struct os_sem {
    pub sem_head: os_sem__bindgen_ty_1,
    pub _pad: u16,
    #[doc = " Number of tokens"]
    pub sem_tokens: u16,
}
#[repr(C)]
pub struct os_sem__bindgen_ty_1 {
    pub slh_first: *mut os_task,
}
impl Default for os_sem__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for os_sem {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a semaphore"]
    #[doc = ""]
    #[doc = " - __`sem`__: Pointer to semaphore"]
    #[doc = "        tokens: # of tokens the semaphore should contain initially."]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    #[doc = "      OS_INVALID_PARM     Semaphore passed in was NULL."]
    #[doc = "      OS_OK               no error."]
    pub fn os_sem_init(sem: *mut os_sem, tokens: u16) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Release a semaphore."]
    #[doc = ""]
    #[doc = " - __`sem`__: Pointer to the semaphore to be released"]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    #[doc = "      OS_INVALID_PARM Semaphore passed in was NULL."]
    #[doc = "      OS_OK No error"]
    pub fn os_sem_release(sem: *mut os_sem) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " os sem pend"]
    #[doc = ""]
    #[doc = " Pend (wait) for a semaphore."]
    #[doc = ""]
    #[doc = " - __`mu`__: Pointer to semaphore."]
    #[doc = " - __`timeout`__: Timeout, in os ticks."]
    #[doc = "                A timeout of 0 means do not wait if not available."]
    #[doc = "                A timeout of OS_TIMEOUT_NEVER means wait forever."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Return: os_error_t"]
    #[doc = "      OS_INVALID_PARM     Semaphore passed in was NULL."]
    #[doc = "      OS_TIMEOUT          Semaphore was owned by another task and timeout=0"]
    #[doc = "      OS_OK               no error."]
    pub fn os_sem_pend(sem: *mut os_sem, timeout: os_time_t) -> os_error_t;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_mempool_module_init();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_msys_init();
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set up the periodic timer to interrupt at a frequency of 'os_ticks_per_sec'."]
    #[doc = " 'prio' is the cpu-specific priority of the periodic timer interrupt."]
    #[doc = ""]
    #[doc = " - __`os_ticks_per_sec`__: Frequency of the OS tick timer"]
    #[doc = " - __`prio`__:             Priority of the OS tick timer"]
    pub fn os_tick_init(os_ticks_per_sec: u32, prio: ::cty::c_int);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Halt CPU for up to 'n' ticks."]
    #[doc = ""]
    #[doc = " - __`n`__: The number of ticks to halt the CPU for"]
    pub fn os_tick_idle(n: os_time_t);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub static mut os_main_task: os_task;
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub static mut os_main_stack: [os_stack_t; 1024usize];
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Idle operating system task, runs when no other tasks are running."]
    #[doc = " The idle task operates in tickless mode, which means it looks for"]
    #[doc = " the next time an event in the system needs to run, and then tells"]
    #[doc = " the architecture specific functions to sleep until that time."]
    #[doc = ""]
    #[doc = " - __`arg`__: unused"]
    pub fn os_idle_task(arg: *mut ::cty::c_void);
}
#[mynewt_macros::safe_wrap(attr)] extern "C" {
    pub fn os_pkg_init();
}
